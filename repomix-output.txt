This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-03-01T17:11:36.931Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  backend/
    declarations/
      backend.did
      backend.did.d.ts
      backend.did.js
      index.d.ts
      index.js
    src/
      service/
        comments.rs
        follows.rs
        get_my_profile.rs
        list_profiles.rs
        mod.rs
        save_my_profile.rs
        search.rs
        tips.rs
        video.rs
        watch.rs
      comment.rs
      follow_relationship.rs
      lib.rs
      tip_record.rs
      user_profile.rs
      video_metadata.rs
      watch_event.rs
    backend.did
    build.rs
    Cargo.toml
  frontend/
    public/
      ethereum.svg
      ic.svg
      react.svg
      siwe.svg
      walletconnect.svg
    src/
      assets/
        ic.svg
      cdp/
        CustomFundWallet.tsx
        FundWallet.tsx
        index.ts
        OnchainKitProvider.tsx
      components/
        header/
          EthButton.tsx
          Header.tsx
          IdentityButton.tsx
          PrincipalDialog.tsx
          SessionButton.tsx
          SessionDialog.tsx
        layout/
          DesktopLayout.tsx
          MobileLayout.tsx
        login/
          ConnectButton.tsx
          LoginButton.tsx
          LoginPage.tsx
        profile/
          AllProfiles.tsx
          EditProfile.tsx
          FollowSection.tsx
          NoProfileMessage.tsx
          ProfileCard.tsx
        search/
          index.ts
          SearchBar.tsx
          SearchResults.tsx
          SimpleSearch.tsx
        ui/
          Button.tsx
          Dialog.tsx
          FollowButton.tsx
          Pill.tsx
        video/
          CommentSection.tsx
          index.ts
          TipHistory.tsx
          TipModal.tsx
          VideoGrid.tsx
          VideoPage.tsx
          VideoViewPage.tsx
        AccountDialog.tsx
        AddressPill.tsx
        ConnectDialog.tsx
        GitHubIcon.tsx
        PrincipalPill.tsx
      context/
        SearchContext.tsx
      eth/
        utils/
          shortenEthAddress.ts
      ic/
        Actors.tsx
      livepeer/
        index.ts
        LivepeerProvider.tsx
        types.ts
        VideoFeed.tsx
        VideoPlayer.tsx
        VideoUpload.tsx
      utils/
        api.ts
      wagmi/
        is-chain-id-supported.tsx
        wagmi.config.ts
      App.tsx
      AuthGuard.tsx
      index.css
      main.tsx
      vite-env.d.ts
    index.html
    README.md
  ic_siwe_provider/
    declarations/
      ic_siwe_provider.did
      ic_siwe_provider.did.d.ts
      ic_siwe_provider.did.js
      index.d.ts
      index.js
.gitignore
Cargo.toml
CHANGELOG.md
dfx.json
eslint.config.js
LICENSE
Makefile
package.json
postcss.config.js
README.md
tailwind.config.js
tsconfig.app.json
tsconfig.app.tsbuildinfo
tsconfig.json
tsconfig.node.json
tsconfig.node.tsbuildinfo
vite.config.ts

================================================================
Files
================================================================

================
File: src/backend/declarations/backend.did
================
type Name = text;
type AvatarUrl = text;
type VideoId = text;
type Title = text;
type Tag = text;
type StorageRef = text;
type Text = text;
type TxHash = text;
type Principal = principal;

// User Profile
type UserProfile = record {
  evm_address : text;
  name : text;
  avatar_url : text;
};

// Video Metadata
type VideoMetadata = record {
  video_id : text;
  uploader_principal : Principal;
  tags : vec Tag;
  title : text;
  storage_ref : opt StorageRef;
  timestamp : nat64;
};

// Watch Event
type WatchEvent = record {
  user_principal : Principal;
  video_id : text;
  watch_duration_sec : nat32;
  liked : bool;
  completed : bool;
  timestamp : nat64;
};

// Tip Record
type TipRecord = record {
  from_addr : text;
  to_addr : text;
  video_id : text;
  amount : nat64;
  tx_hash : text;
  timestamp : nat64;
};

// Comment
type Comment = record {
  commenter_principal : Principal;
  video_id : text;
  text : text;
  timestamp : nat64;
};

// Analytics
type VideoAnalytics = record {
  total_views : nat64;
  total_unique_viewers : nat64;
  total_likes : nat64;
  total_completions : nat64;
  avg_watch_duration : nat64;
};

// Response types
type GetMyProfileResponse = variant {
  Ok : UserProfile;
  Err : text;
};

type SaveMyProfileResponse = variant {
  Ok : UserProfile;
  Err : text;
};

type ListProfilesResponse = variant {
  Ok : vec record { text; UserProfile };
  Err : text;
};

type VideoMetadataResponse = variant {
  Ok : VideoMetadata;
  Err : text;
};

type CommentResponse = variant {
  Ok : Comment;
  Err : text;
};

type TipRecordResponse = variant {
  Ok : TipRecord;
  Err : text;
};

type EmptyResponse = variant {
  Ok;
  Err : text;
};

type VideoAnalyticsResponse = variant {
  Ok : VideoAnalytics;
  Err : text;
};

service : () -> {
  // User Profile
  "get_my_profile" : () -> (GetMyProfileResponse) query;
  "save_my_profile" : (Name, AvatarUrl) -> (SaveMyProfileResponse);
  "list_profiles" : () -> (ListProfilesResponse) query;
  
  // Video Metadata
  "create_video_metadata" : (VideoId, Title, vec Tag, opt StorageRef) -> (VideoMetadataResponse);
  "get_video_metadata" : (VideoId) -> (VideoMetadataResponse) query;
  "list_all_videos" : () -> (vec VideoMetadata) query;
  "list_videos_by_tag" : (Tag) -> (vec VideoMetadata) query;
  "list_videos_by_uploader" : (Principal) -> (vec VideoMetadata) query;
  "update_video_metadata" : (VideoId, opt Title, opt vec Tag, opt StorageRef) -> (VideoMetadataResponse);
  "delete_video" : (VideoId) -> (EmptyResponse);
  
  // Search
  "search_videos" : (text, opt nat32, opt nat32) -> (vec VideoMetadata) query;
  "search_videos_by_tags" : (vec text, opt nat32, opt nat32) -> (vec VideoMetadata) query;
  
  // Watch Events
  "log_watch_event" : (VideoId, nat32, bool, bool) -> (EmptyResponse);
  "get_watch_events" : (VideoId) -> (vec WatchEvent) query;
  "get_my_watch_events" : () -> (vec WatchEvent) query;
  "get_video_analytics" : (VideoId) -> (VideoAnalyticsResponse) query;
  
  // Tips
  "record_tip" : (VideoId, nat64, TxHash) -> (TipRecordResponse);
  "get_tips_for_video" : (VideoId) -> (vec TipRecord) query;
  "get_my_sent_tips" : () -> (vec TipRecord) query;
  "get_my_received_tips" : () -> (vec TipRecord) query;
  
  // Comments
  "post_comment" : (VideoId, Text) -> (CommentResponse);
  "get_comments" : (VideoId) -> (vec Comment) query;
  "get_my_comments" : () -> (vec Comment) query;
  "delete_comment" : (VideoId, nat64) -> (EmptyResponse);
  
  // Follows
  "follow_user" : (Principal) -> (EmptyResponse);
  "unfollow_user" : (Principal) -> (EmptyResponse);
  "get_followers" : (Principal) -> (vec Principal) query;
  "get_following" : (Principal) -> (vec Principal) query;
  "is_following" : (Principal, Principal) -> (bool) query;
};

================
File: src/backend/declarations/backend.did.d.ts
================
import type { Principal } from '@dfinity/principal';
import type { ActorMethod } from '@dfinity/agent';
import type { IDL } from '@dfinity/candid';

export type AvatarUrl = string;
export interface Comment {
  'commenter_principal' : Principal,
  'text' : string,
  'timestamp' : bigint,
  'video_id' : string,
}
export type CommentResponse = { 'Ok' : Comment } |
  { 'Err' : string };
export type EmptyResponse = { 'Ok' : null } |
  { 'Err' : string };
export type GetMyProfileResponse = { 'Ok' : UserProfile } |
  { 'Err' : string };
export type ListProfilesResponse = { 'Ok' : Array<[string, UserProfile]> } |
  { 'Err' : string };
export type Name = string;
export type Principal = Principal;
export type SaveMyProfileResponse = { 'Ok' : UserProfile } |
  { 'Err' : string };
export type StorageRef = string;
export type Tag = string;
export type Text = string;
export interface TipRecord {
  'from_addr' : string,
  'to_addr' : string,
  'timestamp' : bigint,
  'tx_hash' : string,
  'amount' : bigint,
  'video_id' : string,
}
export type TipRecordResponse = { 'Ok' : TipRecord } |
  { 'Err' : string };
export type Title = string;
export type TxHash = string;
export interface UserProfile {
  'evm_address' : string,
  'avatar_url' : string,
  'name' : string,
}
export interface VideoAnalytics {
  'total_likes' : bigint,
  'total_unique_viewers' : bigint,
  'total_views' : bigint,
  'avg_watch_duration' : bigint,
  'total_completions' : bigint,
}
export type VideoAnalyticsResponse = { 'Ok' : VideoAnalytics } |
  { 'Err' : string };
export type VideoId = string;
export interface VideoMetadata {
  'title' : string,
  'uploader_principal' : Principal,
  'storage_ref' : [] | [StorageRef],
  'tags' : Array<Tag>,
  'timestamp' : bigint,
  'video_id' : string,
}
export type VideoMetadataResponse = { 'Ok' : VideoMetadata } |
  { 'Err' : string };
export interface WatchEvent {
  'user_principal' : Principal,
  'watch_duration_sec' : number,
  'completed' : boolean,
  'liked' : boolean,
  'timestamp' : bigint,
  'video_id' : string,
}
export interface _SERVICE {
  'create_video_metadata' : ActorMethod<
    [VideoId, Title, Array<Tag>, [] | [StorageRef]],
    VideoMetadataResponse
  >,
  'delete_comment' : ActorMethod<[VideoId, bigint], EmptyResponse>,
  'delete_video' : ActorMethod<[VideoId], EmptyResponse>,
  'follow_user' : ActorMethod<[Principal], EmptyResponse>,
  'get_comments' : ActorMethod<[VideoId], Array<Comment>>,
  'get_followers' : ActorMethod<[Principal], Array<Principal>>,
  'get_following' : ActorMethod<[Principal], Array<Principal>>,
  'get_my_comments' : ActorMethod<[], Array<Comment>>,
  'get_my_profile' : ActorMethod<[], GetMyProfileResponse>,
  'get_my_received_tips' : ActorMethod<[], Array<TipRecord>>,
  'get_my_sent_tips' : ActorMethod<[], Array<TipRecord>>,
  'get_my_watch_events' : ActorMethod<[], Array<WatchEvent>>,
  'get_tips_for_video' : ActorMethod<[VideoId], Array<TipRecord>>,
  'get_video_analytics' : ActorMethod<[VideoId], VideoAnalyticsResponse>,
  'get_video_metadata' : ActorMethod<[VideoId], VideoMetadataResponse>,
  'get_watch_events' : ActorMethod<[VideoId], Array<WatchEvent>>,
  'is_following' : ActorMethod<[Principal, Principal], boolean>,
  'list_all_videos' : ActorMethod<[], Array<VideoMetadata>>,
  'list_profiles' : ActorMethod<[], ListProfilesResponse>,
  'list_videos_by_tag' : ActorMethod<[Tag], Array<VideoMetadata>>,
  'list_videos_by_uploader' : ActorMethod<[Principal], Array<VideoMetadata>>,
  'log_watch_event' : ActorMethod<
    [VideoId, number, boolean, boolean],
    EmptyResponse
  >,
  'post_comment' : ActorMethod<[VideoId, Text], CommentResponse>,
  'record_tip' : ActorMethod<[VideoId, bigint, TxHash], TipRecordResponse>,
  'save_my_profile' : ActorMethod<[Name, AvatarUrl], SaveMyProfileResponse>,
  'search_videos' : ActorMethod<
    [string, [] | [number], [] | [number]],
    Array<VideoMetadata>
  >,
  'search_videos_by_tags' : ActorMethod<
    [Array<string>, [] | [number], [] | [number]],
    Array<VideoMetadata>
  >,
  'unfollow_user' : ActorMethod<[Principal], EmptyResponse>,
  'update_video_metadata' : ActorMethod<
    [VideoId, [] | [Title], [] | [Array<Tag>], [] | [StorageRef]],
    VideoMetadataResponse
  >,
}
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];

================
File: src/backend/declarations/backend.did.js
================
export const idlFactory = ({ IDL }) => {
  const VideoId = IDL.Text;
  const Title = IDL.Text;
  const Tag = IDL.Text;
  const StorageRef = IDL.Text;
  const Principal = IDL.Principal;
  const VideoMetadata = IDL.Record({
    'title' : IDL.Text,
    'uploader_principal' : Principal,
    'storage_ref' : IDL.Opt(StorageRef),
    'tags' : IDL.Vec(Tag),
    'timestamp' : IDL.Nat64,
    'video_id' : IDL.Text,
  });
  const VideoMetadataResponse = IDL.Variant({
    'Ok' : VideoMetadata,
    'Err' : IDL.Text,
  });
  const EmptyResponse = IDL.Variant({ 'Ok' : IDL.Null, 'Err' : IDL.Text });
  const Comment = IDL.Record({
    'commenter_principal' : Principal,
    'text' : IDL.Text,
    'timestamp' : IDL.Nat64,
    'video_id' : IDL.Text,
  });
  const UserProfile = IDL.Record({
    'evm_address' : IDL.Text,
    'avatar_url' : IDL.Text,
    'name' : IDL.Text,
  });
  const GetMyProfileResponse = IDL.Variant({
    'Ok' : UserProfile,
    'Err' : IDL.Text,
  });
  const TipRecord = IDL.Record({
    'from_addr' : IDL.Text,
    'to_addr' : IDL.Text,
    'timestamp' : IDL.Nat64,
    'tx_hash' : IDL.Text,
    'amount' : IDL.Nat64,
    'video_id' : IDL.Text,
  });
  const WatchEvent = IDL.Record({
    'user_principal' : Principal,
    'watch_duration_sec' : IDL.Nat32,
    'completed' : IDL.Bool,
    'liked' : IDL.Bool,
    'timestamp' : IDL.Nat64,
    'video_id' : IDL.Text,
  });
  const VideoAnalytics = IDL.Record({
    'total_likes' : IDL.Nat64,
    'total_unique_viewers' : IDL.Nat64,
    'total_views' : IDL.Nat64,
    'avg_watch_duration' : IDL.Nat64,
    'total_completions' : IDL.Nat64,
  });
  const VideoAnalyticsResponse = IDL.Variant({
    'Ok' : VideoAnalytics,
    'Err' : IDL.Text,
  });
  const ListProfilesResponse = IDL.Variant({
    'Ok' : IDL.Vec(IDL.Tuple(IDL.Text, UserProfile)),
    'Err' : IDL.Text,
  });
  const Text = IDL.Text;
  const CommentResponse = IDL.Variant({ 'Ok' : Comment, 'Err' : IDL.Text });
  const TxHash = IDL.Text;
  const TipRecordResponse = IDL.Variant({ 'Ok' : TipRecord, 'Err' : IDL.Text });
  const Name = IDL.Text;
  const AvatarUrl = IDL.Text;
  const SaveMyProfileResponse = IDL.Variant({
    'Ok' : UserProfile,
    'Err' : IDL.Text,
  });
  return IDL.Service({
    'create_video_metadata' : IDL.Func(
        [VideoId, Title, IDL.Vec(Tag), IDL.Opt(StorageRef)],
        [VideoMetadataResponse],
        [],
      ),
    'delete_comment' : IDL.Func([VideoId, IDL.Nat64], [EmptyResponse], []),
    'delete_video' : IDL.Func([VideoId], [EmptyResponse], []),
    'follow_user' : IDL.Func([Principal], [EmptyResponse], []),
    'get_comments' : IDL.Func([VideoId], [IDL.Vec(Comment)], ['query']),
    'get_followers' : IDL.Func([Principal], [IDL.Vec(Principal)], ['query']),
    'get_following' : IDL.Func([Principal], [IDL.Vec(Principal)], ['query']),
    'get_my_comments' : IDL.Func([], [IDL.Vec(Comment)], ['query']),
    'get_my_profile' : IDL.Func([], [GetMyProfileResponse], ['query']),
    'get_my_received_tips' : IDL.Func([], [IDL.Vec(TipRecord)], ['query']),
    'get_my_sent_tips' : IDL.Func([], [IDL.Vec(TipRecord)], ['query']),
    'get_my_watch_events' : IDL.Func([], [IDL.Vec(WatchEvent)], ['query']),
    'get_tips_for_video' : IDL.Func([VideoId], [IDL.Vec(TipRecord)], ['query']),
    'get_video_analytics' : IDL.Func(
        [VideoId],
        [VideoAnalyticsResponse],
        ['query'],
      ),
    'get_video_metadata' : IDL.Func(
        [VideoId],
        [VideoMetadataResponse],
        ['query'],
      ),
    'get_watch_events' : IDL.Func([VideoId], [IDL.Vec(WatchEvent)], ['query']),
    'is_following' : IDL.Func([Principal, Principal], [IDL.Bool], ['query']),
    'list_all_videos' : IDL.Func([], [IDL.Vec(VideoMetadata)], ['query']),
    'list_profiles' : IDL.Func([], [ListProfilesResponse], ['query']),
    'list_videos_by_tag' : IDL.Func([Tag], [IDL.Vec(VideoMetadata)], ['query']),
    'list_videos_by_uploader' : IDL.Func(
        [Principal],
        [IDL.Vec(VideoMetadata)],
        ['query'],
      ),
    'log_watch_event' : IDL.Func(
        [VideoId, IDL.Nat32, IDL.Bool, IDL.Bool],
        [EmptyResponse],
        [],
      ),
    'post_comment' : IDL.Func([VideoId, Text], [CommentResponse], []),
    'record_tip' : IDL.Func(
        [VideoId, IDL.Nat64, TxHash],
        [TipRecordResponse],
        [],
      ),
    'save_my_profile' : IDL.Func(
        [Name, AvatarUrl],
        [SaveMyProfileResponse],
        [],
      ),
    'search_videos' : IDL.Func(
        [IDL.Text, IDL.Opt(IDL.Nat32), IDL.Opt(IDL.Nat32)],
        [IDL.Vec(VideoMetadata)],
        ['query'],
      ),
    'search_videos_by_tags' : IDL.Func(
        [IDL.Vec(IDL.Text), IDL.Opt(IDL.Nat32), IDL.Opt(IDL.Nat32)],
        [IDL.Vec(VideoMetadata)],
        ['query'],
      ),
    'unfollow_user' : IDL.Func([Principal], [EmptyResponse], []),
    'update_video_metadata' : IDL.Func(
        [VideoId, IDL.Opt(Title), IDL.Opt(IDL.Vec(Tag)), IDL.Opt(StorageRef)],
        [VideoMetadataResponse],
        [],
      ),
  });
};
export const init = ({ IDL }) => { return []; };

================
File: src/backend/declarations/index.d.ts
================
import type {
  ActorSubclass,
  HttpAgentOptions,
  ActorConfig,
  Agent,
} from "@dfinity/agent";
import type { Principal } from "@dfinity/principal";
import type { IDL } from "@dfinity/candid";

import { _SERVICE } from './backend.did';

export declare const idlFactory: IDL.InterfaceFactory;
export declare const canisterId: string;

export declare interface CreateActorOptions {
  /**
   * @see {@link Agent}
   */
  agent?: Agent;
  /**
   * @see {@link HttpAgentOptions}
   */
  agentOptions?: HttpAgentOptions;
  /**
   * @see {@link ActorConfig}
   */
  actorOptions?: ActorConfig;
}

/**
 * Intializes an {@link ActorSubclass}, configured with the provided SERVICE interface of a canister.
 * @constructs {@link ActorSubClass}
 * @param {string | Principal} canisterId - ID of the canister the {@link Actor} will talk to
 * @param {CreateActorOptions} options - see {@link CreateActorOptions}
 * @param {CreateActorOptions["agent"]} options.agent - a pre-configured agent you'd like to use. Supercedes agentOptions
 * @param {CreateActorOptions["agentOptions"]} options.agentOptions - options to set up a new agent
 * @see {@link HttpAgentOptions}
 * @param {CreateActorOptions["actorOptions"]} options.actorOptions - options for the Actor
 * @see {@link ActorConfig}
 */
export declare const createActor: (
  canisterId: string | Principal,
  options?: CreateActorOptions
) => ActorSubclass<_SERVICE>;

/**
 * Intialized Actor using default settings, ready to talk to a canister using its candid interface
 * @constructs {@link ActorSubClass}
 */
export declare const backend: ActorSubclass<_SERVICE>;

================
File: src/backend/declarations/index.js
================
import { Actor, HttpAgent } from "@dfinity/agent";

// Imports and re-exports candid interface
import { idlFactory } from "./backend.did.js";
export { idlFactory } from "./backend.did.js";

/* CANISTER_ID is replaced by webpack based on node environment
 * Note: canister environment variable will be standardized as
 * process.env.CANISTER_ID_<CANISTER_NAME_UPPERCASE>
 * beginning in dfx 0.15.0
 */
export const canisterId =
  process.env.CANISTER_ID_BACKEND;

export const createActor = (canisterId, options = {}) => {
  const agent = options.agent || new HttpAgent({ ...options.agentOptions });

  if (options.agent && options.agentOptions) {
    console.warn(
      "Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent."
    );
  }

  // Fetch root key for certificate validation during development
  if (process.env.DFX_NETWORK !== "ic") {
    agent.fetchRootKey().catch((err) => {
      console.warn(
        "Unable to fetch root key. Check to ensure that your local replica is running"
      );
      console.error(err);
    });
  }

  // Creates an actor with using the candid interface and the HttpAgent
  return Actor.createActor(idlFactory, {
    agent,
    canisterId,
    ...options.actorOptions,
  });
};

export const backend = canisterId ? createActor(canisterId) : undefined;

================
File: src/backend/src/service/comments.rs
================
use ic_cdk::{query, update};
use std::time::{SystemTime, UNIX_EPOCH};

use crate::{comment::{Comment, CommentList}, COMMENTS, VIDEOS};

/// Posts a comment on a video
#[update]
pub fn post_comment(video_id: String, text: String) -> Result<Comment, String> {
    // Verify the video exists
    VIDEOS.with(|videos| {
        if !videos.borrow().contains_key(&video_id) {
            return Err("Video not found".to_string());
        }
        Ok(())
    })?;
    
    // Generate timestamp
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs();
    
    // Create comment
    let comment = Comment {
        commenter_principal: ic_cdk::caller(),
        video_id: video_id.clone(),
        text,
        timestamp,
    };
    
    // Store comment
    COMMENTS.with(|comments| {
        let mut comments_map = comments.borrow_mut();
        let video_comments = match comments_map.get(&video_id) {
            Some(comment_list) => {
                let mut existing = comment_list.0.clone();
                existing.push(comment.clone());
                CommentList(existing)
            }
            None => CommentList(vec![comment.clone()]),
        };
        comments_map.insert(video_id, video_comments);
        Ok(comment)
    })
}

/// Gets comments for a video
#[query]
pub fn get_comments(video_id: String) -> Vec<Comment> {
    COMMENTS.with(|comments| {
        comments
            .borrow()
            .get(&video_id)
            .map(|comment_list| comment_list.0.clone())
            .unwrap_or_default()
    })
}

/// Gets all comments by the calling user
#[query]
pub fn get_my_comments() -> Vec<Comment> {
    let caller = ic_cdk::caller();
    
    COMMENTS.with(|comments| {
        comments
            .borrow()
            .iter()
            .flat_map(|(_, comment_list)| comment_list.0.clone())
            .filter(|comment| comment.commenter_principal == caller)
            .collect()
    })
}

/// Deletes a comment (only by the commenter)
#[update]
pub fn delete_comment(video_id: String, timestamp: u64) -> Result<(), String> {
    let caller = ic_cdk::caller();
    
    COMMENTS.with(|comments| {
        let mut comments_map = comments.borrow_mut();
        
        // Check if the video has comments
        if let Some(comment_list) = comments_map.get(&video_id) {
            let mut video_comments = comment_list.0.clone();
            
            // Find the comment index
            let comment_idx = video_comments
                .iter()
                .position(|c| c.timestamp == timestamp && c.commenter_principal == caller);
            
            if let Some(idx) = comment_idx {
                // Remove the comment
                video_comments.remove(idx);
                comments_map.insert(video_id, CommentList(video_comments));
                Ok(())
            } else {
                Err("Comment not found or you don't have permission to delete it".to_string())
            }
        } else {
            Err("No comments found for this video".to_string())
        }
    })
}

================
File: src/backend/src/service/follows.rs
================
// Follow system service for ShawtyFormVideo
// Provides API methods for handling user follow relationships

use crate::{FollowRelationship, FollowRelationshipList, FOLLOW_RELATIONSHIPS};
use candid::Principal;
use ic_cdk::caller;
use std::time::{SystemTime, UNIX_EPOCH};

/// Enables a user to follow another user
/// 
/// # Arguments
/// 
/// * `principal_to_follow` - The principal ID of the user to follow
/// 
/// # Returns
/// 
/// * `Result<(), String>` - Ok(()) on success, Err with message on failure
#[ic_cdk::update]
pub fn follow_user(principal_to_follow: Principal) -> Result<(), String> {
    // Get the caller's principal
    let caller_principal = caller();
    
    // Prevent self-following
    if caller_principal == principal_to_follow {
        return Err("You cannot follow yourself".to_string());
    }
    
    // Create a composite key for storage
    let relationship_key = format!("{}:{}", 
        caller_principal.to_string(), 
        principal_to_follow.to_string()
    );
    
    // Check if already following
    if FOLLOW_RELATIONSHIPS.with(|relationships| {
        relationships.borrow().contains_key(&relationship_key)
    }) {
        return Err("You are already following this user".to_string());
    }

    // Create the follow relationship object
    let follow_relationship = FollowRelationship {
        follower_principal: caller_principal,
        followed_principal: principal_to_follow,
        timestamp: SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs(),
    };
    
    // Store the relationship in stable storage
    FOLLOW_RELATIONSHIPS.with(|relationships| {
        let mut relationships_map = relationships.borrow_mut();
        relationships_map.insert(
            relationship_key,
            FollowRelationshipList(vec![follow_relationship]),
        );
    });
    
    Ok(())
}

/// Enables a user to unfollow another user
/// 
/// # Arguments
/// 
/// * `principal_to_unfollow` - The principal ID of the user to unfollow
/// 
/// # Returns
/// 
/// * `Result<(), String>` - Ok(()) on success, Err with message on failure
#[ic_cdk::update]
pub fn unfollow_user(principal_to_unfollow: Principal) -> Result<(), String> {
    // Get the caller's principal
    let caller_principal = caller();
    
    // Create the composite key for lookup
    let relationship_key = format!("{}:{}", 
        caller_principal.to_string(), 
        principal_to_unfollow.to_string()
    );
    
    // Remove the relationship from stable storage
    FOLLOW_RELATIONSHIPS.with(|relationships| {
        let mut relationships_map = relationships.borrow_mut();
        if relationships_map.contains_key(&relationship_key) {
            relationships_map.remove(&relationship_key);
            Ok(())
        } else {
            Err("You are not following this user".to_string())
        }
    })
}

/// Retrieves all followers of a specified user
/// 
/// # Arguments
/// 
/// * `user_principal` - The principal ID of the user
/// 
/// # Returns
/// 
/// * `Vec<Principal>` - List of principal IDs that follow the user
#[ic_cdk::query]
pub fn get_followers(user_principal: Principal) -> Vec<Principal> {
    // Query storage for all relationships where followed_principal matches the given user
    // We use the key pattern to efficiently find relationships
    let user_str = user_principal.to_string();
    
    FOLLOW_RELATIONSHIPS.with(|relationships| {
        relationships
            .borrow()
            .iter()
            .filter(|(key, _)| {
                let parts: Vec<&str> = key.split(':').collect();
                parts.len() == 2 && parts[1] == user_str
            })
            .map(|(key, _)| {
                let parts: Vec<&str> = key.split(':').collect();
                // Safe to unwrap as we checked the key format in filter
                Principal::from_text(parts[0]).unwrap_or_else(|_| Principal::anonymous())
            })
            .collect()
    })
}

/// Retrieves all users that a specified user is following
/// 
/// # Arguments
/// 
/// * `user_principal` - The principal ID of the user
/// 
/// # Returns
/// 
/// * `Vec<Principal>` - List of principal IDs that the user follows
#[ic_cdk::query]
pub fn get_following(user_principal: Principal) -> Vec<Principal> {
    // Query storage for all relationships where follower_principal matches the given user
    // We use the key pattern to efficiently find relationships
    let user_str = user_principal.to_string();
    
    FOLLOW_RELATIONSHIPS.with(|relationships| {
        relationships
            .borrow()
            .iter()
            .filter(|(key, _)| {
                let parts: Vec<&str> = key.split(':').collect();
                parts.len() == 2 && parts[0] == user_str
            })
            .map(|(key, _)| {
                let parts: Vec<&str> = key.split(':').collect();
                // Safe to unwrap as we checked the key format in filter
                Principal::from_text(parts[1]).unwrap_or_else(|_| Principal::anonymous())
            })
            .collect()
    })
}

/// Checks if one user is following another
/// 
/// # Arguments
/// 
/// * `follower` - Principal ID of the potential follower
/// * `followed` - Principal ID of the potentially followed user
/// 
/// # Returns
/// 
/// * `bool` - True if follower is following followed, false otherwise
#[ic_cdk::query]
pub fn is_following(follower: Principal, followed: Principal) -> bool {
    // Create the composite key and check if it exists in storage
    let relationship_key = format!("{}:{}", follower.to_string(), followed.to_string());
    
    FOLLOW_RELATIONSHIPS.with(|relationships| {
        relationships.borrow().contains_key(&relationship_key)
    })
}

================
File: src/backend/src/service/get_my_profile.rs
================
use ic_cdk::query;

use crate::{user_profile::UserProfile, USER_PROFILES};

/// Returns the profile of the caller if it exists.
#[query]
pub fn get_my_profile() -> Result<UserProfile, String> {
    USER_PROFILES
        .with_borrow(|p| p.get(&ic_cdk::caller().to_string()))
        .ok_or("No profile found for the given address".to_string())
}

================
File: src/backend/src/service/list_profiles.rs
================
use ic_cdk::query;

use crate::{user_profile::UserProfile, USER_PROFILES};

#[query]
pub fn list_profiles() -> Result<Vec<(String, UserProfile)>, String> {
    let profiles = USER_PROFILES.with(|p| p.borrow().iter().collect::<Vec<_>>());
    Ok(profiles)
}

================
File: src/backend/src/service/mod.rs
================
pub mod get_my_profile;
pub mod list_profiles;
pub mod save_my_profile;
pub mod video;
pub mod watch;
pub mod tips;
pub mod comments;
pub mod follows;
pub mod search;

================
File: src/backend/src/service/save_my_profile.rs
================
use ic_cdk::update;
use serde_bytes::ByteBuf;

use crate::{
    declarations::ic_siwe_provider::{ic_siwe_provider, GetAddressResponse},
    user_profile::UserProfile,
    USER_PROFILES,
};

#[update]
async fn save_my_profile(name: String, avatar_url: String) -> Result<UserProfile, String> {
    // Get the address of the caller from the siwe provider canister, return error if it fails. A failure
    // here means that the caller is not authenticated using the siwe provider. This might happen if the
    // caller uses an anonymous principal or has authenticated using a different identity provider.
    let evm_address = get_address().await?;

    // If user has an address and thus is authenticated, create a profile and save it.
    let profile = UserProfile {
        evm_address,
        name,
        avatar_url,
    };

    USER_PROFILES.with(|p| {
        let mut profiles = p.borrow_mut();
        profiles.insert(ic_cdk::caller().to_string(), profile.clone());
    });

    Ok(profile)
}

pub async fn get_address() -> Result<String, String> {
    let response = ic_siwe_provider
        .get_address(ByteBuf::from(ic_cdk::caller().as_slice()))
        .await;

    let address = match response {
        Ok((inner_result,)) => {
            // Handle the inner Result (GetAddressResponse)
            match inner_result {
                GetAddressResponse::Ok(address) => address, // Successfully got the address
                GetAddressResponse::Err(e) => return Err(e), // Handle error in GetAddressResponse
            }
        }
        Err(_) => return Err("Failed to get the caller address".to_string()), // Handle ic_cdk::call error
    };

    // Return the calling principal and address
    Ok(address)
}

================
File: src/backend/src/service/search.rs
================
use crate::{VideoMetadata, VIDEOS};
use ic_cdk::query;

/// Search for videos matching the given query in title or tags
#[query]
pub fn search_videos(
    query: String,
    limit: Option<u32>,
    offset: Option<u32>
) -> Vec<VideoMetadata> {
    // Empty query returns most recent videos
    if query.is_empty() {
        return list_recent_videos(limit, offset);
    }
    
    let query = query.to_lowercase(); // Case-insensitive search
    
    VIDEOS.with(|videos| {
        let videos_map = videos.borrow();
        let mut results: Vec<VideoMetadata> = videos_map
            .iter()
            .filter(|(_, metadata)| {
                // Search in title
                let title_match = metadata.title.to_lowercase().contains(&query);
                
                // Search in tags
                let tag_match = metadata.tags.iter().any(|tag| 
                    tag.to_lowercase().contains(&query)
                );
                
                // Match if either title or tags contain the query
                title_match || tag_match
            })
            .map(|(_, metadata)| metadata.clone())
            .collect();
        
        // Sort by timestamp (newest first)
        results.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
        
        // Apply pagination
        apply_pagination(results, limit, offset)
    })
}

/// Search for videos matching all specified tags
#[query]
pub fn search_videos_by_tags(
    tags: Vec<String>,
    limit: Option<u32>,
    offset: Option<u32>
) -> Vec<VideoMetadata> {
    // If no tags provided, return recent videos
    if tags.is_empty() {
        return list_recent_videos(limit, offset);
    }
    
    // Convert tags to lowercase for case-insensitive matching
    let tags_lower: Vec<String> = tags.iter().map(|t| t.to_lowercase()).collect();
    
    VIDEOS.with(|videos| {
        let videos_map = videos.borrow();
        let mut results: Vec<VideoMetadata> = videos_map
            .iter()
            .filter(|(_, metadata)| {
                // Video matches if it contains all the specified tags
                tags_lower.iter().all(|search_tag| {
                    metadata.tags.iter().any(|video_tag| 
                        video_tag.to_lowercase() == *search_tag
                    )
                })
            })
            .map(|(_, metadata)| metadata.clone())
            .collect();
            
        // Sort by timestamp (newest first)
        results.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
        
        // Apply pagination
        apply_pagination(results, limit, offset)
    })
}

/// Get most recent videos
pub fn list_recent_videos(
    limit: Option<u32>,
    offset: Option<u32>
) -> Vec<VideoMetadata> {
    VIDEOS.with(|videos| {
        let videos_map = videos.borrow();
        let mut results: Vec<VideoMetadata> = videos_map
            .iter()
            .map(|(_, metadata)| metadata.clone())
            .collect();
            
        // Sort by timestamp (newest first)
        results.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
        
        // Apply pagination
        apply_pagination(results, limit, offset)
    })
}

/// Helper function to apply pagination to a vector of results
fn apply_pagination(
    results: Vec<VideoMetadata>,
    limit: Option<u32>,
    offset: Option<u32>
) -> Vec<VideoMetadata> {
    let start = offset.unwrap_or(0) as usize;
    let end = if let Some(limit_val) = limit {
        start + limit_val as usize
    } else {
        results.len()
    };
    
    if start < results.len() {
        results[start..std::cmp::min(end, results.len())].to_vec()
    } else {
        Vec::new()
    }
}

================
File: src/backend/src/service/tips.rs
================
use ic_cdk::{query, update};
use std::time::{SystemTime, UNIX_EPOCH};

use crate::{
    tip_record::{TipRecord, TipRecordList}, 
    TIP_RECORDS, 
    VIDEOS, 
    USER_PROFILES,
    service::save_my_profile::get_address
};

/// Records a tip transaction for a video
#[update]
pub async fn record_tip(
    video_id: String,
    amount: u64,
    tx_hash: String
) -> Result<TipRecord, String> {
    // Verify the video exists
    let to_addr = VIDEOS.with(|videos| {
        let videos_map = videos.borrow();
        if !videos_map.contains_key(&video_id) {
            return Err("Video not found".to_string());
        }
        
        // Get the video's uploader principal
        let uploader_principal = videos_map.get(&video_id).unwrap().uploader_principal;
        
        // Look up the uploader's address from user profiles
        USER_PROFILES.with(|profiles| {
            profiles
                .borrow()
                .get(&uploader_principal.to_string())
                .map(|profile| profile.evm_address.clone())
                .ok_or("Video uploader has no profile with EVM address".to_string())
        })
    })?;
    
    // Get the tipper's address
    let from_addr = get_address().await?;
    
    // Generate timestamp
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs();
    
    // Create tip record
    let tip = TipRecord {
        from_addr,
        to_addr,
        video_id: video_id.clone(),
        amount,
        tx_hash,
        timestamp,
    };
    
    // Store tip record
    TIP_RECORDS.with(|tips| {
        let mut tips_map = tips.borrow_mut();
        let tip_records = match tips_map.get(&video_id) {
            Some(record_list) => {
                let mut records = record_list.0.clone();
                records.push(tip.clone());
                TipRecordList(records)
            }
            None => TipRecordList(vec![tip.clone()]),
        };
        tips_map.insert(video_id, tip_records);
        Ok(tip)
    })
}

/// Gets tips for a specific video
#[query]
pub fn get_tips_for_video(video_id: String) -> Vec<TipRecord> {
    TIP_RECORDS.with(|tips| {
        tips.borrow()
            .get(&video_id)
            .map(|record_list| record_list.0.clone())
            .unwrap_or_default()
    })
}

/// Gets all tips sent by the calling user
#[query]
pub async fn get_my_sent_tips() -> Result<Vec<TipRecord>, String> {
    let my_addr = get_address().await?;
    
    Ok(TIP_RECORDS.with(|tips| {
        tips.borrow()
            .iter()
            .flat_map(|(_, record_list)| record_list.0.clone())
            .filter(|record| record.from_addr == my_addr)
            .collect()
    }))
}

/// Gets all tips received by the calling user
#[query]
pub async fn get_my_received_tips() -> Result<Vec<TipRecord>, String> {
    let my_addr = get_address().await?;
    
    Ok(TIP_RECORDS.with(|tips| {
        tips.borrow()
            .iter()
            .flat_map(|(_, record_list)| record_list.0.clone())
            .filter(|record| record.to_addr == my_addr)
            .collect()
    }))
}

================
File: src/backend/src/service/video.rs
================
use candid::Principal;
use ic_cdk::{query, update};
use std::time::{SystemTime, UNIX_EPOCH};

use crate::{video_metadata::VideoMetadata, VIDEOS};

/// Creates a new video metadata entry
#[update]
pub fn create_video_metadata(
    video_id: String,
    title: String,
    tags: Vec<String>,
    storage_ref: Option<String>,
) -> Result<VideoMetadata, String> {
    // Generate timestamp
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs();

    // Create metadata
    let metadata = VideoMetadata {
        video_id: video_id.clone(),
        uploader_principal: ic_cdk::caller(),
        tags,
        title,
        storage_ref,
        timestamp,
    };

    // Store it
    VIDEOS.with(|videos| {
        let mut videos_map = videos.borrow_mut();
        if videos_map.contains_key(&video_id) {
            return Err("Video ID already exists".to_string());
        }
        videos_map.insert(video_id, metadata.clone());
        Ok(metadata)
    })
}

/// Returns a video's metadata by ID
#[query]
pub fn get_video_metadata(video_id: String) -> Result<VideoMetadata, String> {
    VIDEOS.with(|videos| {
        videos
            .borrow()
            .get(&video_id)
            .ok_or_else(|| "Video not found".to_string())
    })
}

/// Lists all videos
#[query]
pub fn list_all_videos() -> Vec<VideoMetadata> {
    VIDEOS.with(|videos| {
        videos
            .borrow()
            .iter()
            .map(|(_, metadata)| metadata)
            .collect()
    })
}

/// Lists videos by tag
#[query]
pub fn list_videos_by_tag(tag: String) -> Vec<VideoMetadata> {
    VIDEOS.with(|videos| {
        videos
            .borrow()
            .iter()
            .filter(|(_, metadata)| metadata.tags.contains(&tag))
            .map(|(_, metadata)| metadata)
            .collect()
    })
}

/// Lists videos by uploader
#[query]
pub fn list_videos_by_uploader(uploader: Principal) -> Vec<VideoMetadata> {
    VIDEOS.with(|videos| {
        videos
            .borrow()
            .iter()
            .filter(|(_, metadata)| metadata.uploader_principal == uploader)
            .map(|(_, metadata)| metadata)
            .collect()
    })
}

/// Updates a video's metadata
#[update]
pub fn update_video_metadata(
    video_id: String,
    title: Option<String>,
    tags: Option<Vec<String>>,
    storage_ref: Option<String>,
) -> Result<VideoMetadata, String> {
    VIDEOS.with(|videos| {
        let mut videos_map = videos.borrow_mut();
        
        // Check if video exists
        if let Some(mut metadata) = videos_map.get(&video_id) {
            // Verify ownership
            if metadata.uploader_principal != ic_cdk::caller() {
                return Err("Only the uploader can update video metadata".to_string());
            }
            
            // Update fields if provided
            if let Some(new_title) = title {
                metadata.title = new_title;
            }
            
            if let Some(new_tags) = tags {
                metadata.tags = new_tags;
            }
            
            if storage_ref.is_some() {
                metadata.storage_ref = storage_ref;
            }
            
            // Save updated metadata
            videos_map.insert(video_id, metadata.clone());
            Ok(metadata)
        } else {
            Err("Video not found".to_string())
        }
    })
}

/// Deletes a video (only by uploader)
#[update]
pub fn delete_video(video_id: String) -> Result<(), String> {
    VIDEOS.with(|videos| {
        let mut videos_map = videos.borrow_mut();
        
        // Check if video exists
        if let Some(metadata) = videos_map.get(&video_id) {
            // Verify ownership
            if metadata.uploader_principal != ic_cdk::caller() {
                return Err("Only the uploader can delete the video".to_string());
            }
            
            // Delete video
            videos_map.remove(&video_id);
            Ok(())
        } else {
            Err("Video not found".to_string())
        }
    })
}

================
File: src/backend/src/service/watch.rs
================
use ic_cdk::{query, update};
use std::time::{SystemTime, UNIX_EPOCH};

use crate::{watch_event::{WatchEvent, WatchEventList}, WATCH_LOG, VIDEOS};

/// Logs a watch event for a video
#[update]
pub fn log_watch_event(
    video_id: String,
    watch_duration_sec: u32,
    liked: bool,
    completed: bool
) -> Result<(), String> {
    // Verify the video exists
    VIDEOS.with(|videos| {
        if !videos.borrow().contains_key(&video_id) {
            return Err("Video not found".to_string());
        }
        Ok(())
    })?;

    // Generate timestamp
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs();

    // Create watch event
    let event = WatchEvent {
        user_principal: ic_cdk::caller(),
        video_id: video_id.clone(),
        watch_duration_sec,
        liked,
        completed,
        timestamp,
    };

    // Store event
    WATCH_LOG.with(|log| {
        let mut log_map = log.borrow_mut();
        let events = match log_map.get(&video_id) {
            Some(event_list) => {
                let mut events = event_list.0.clone();
                events.push(event);
                WatchEventList(events)
            }
            None => WatchEventList(vec![event]),
        };
        log_map.insert(video_id, events);
        Ok(())
    })
}

/// Returns all watch events for a specific video
#[query]
pub fn get_watch_events(video_id: String) -> Vec<WatchEvent> {
    WATCH_LOG.with(|log| {
        log.borrow()
            .get(&video_id)
            .map(|event_list| event_list.0.clone())
            .unwrap_or_default()
    })
}

/// Returns watch events for the calling user
#[query]
pub fn get_my_watch_events() -> Vec<WatchEvent> {
    let caller = ic_cdk::caller();
    
    WATCH_LOG.with(|log| {
        log.borrow()
            .iter()
            .flat_map(|(_, event_list)| event_list.0.clone())
            .filter(|event| event.user_principal == caller)
            .collect()
    })
}

/// Returns analytics for a specific video
#[query]
pub fn get_video_analytics(video_id: String) -> Result<VideoAnalytics, String> {
    // Verify the video exists
    VIDEOS.with(|videos| {
        if !videos.borrow().contains_key(&video_id) {
            return Err("Video not found".to_string());
        }
        Ok(())
    })?;

    let events = WATCH_LOG.with(|log| {
        log.borrow()
            .get(&video_id)
            .map(|event_list| event_list.0.clone())
            .unwrap_or_default()
    });

    // Calculate analytics
    let total_views = events.len() as u64;
    let total_unique_viewers = events
        .iter()
        .map(|e| e.user_principal)
        .collect::<std::collections::HashSet<_>>()
        .len() as u64;
    
    let total_likes = events.iter().filter(|e| e.liked).count() as u64;
    let total_completions = events.iter().filter(|e| e.completed).count() as u64;
    
    let avg_watch_duration = if !events.is_empty() {
        events.iter().map(|e| e.watch_duration_sec as u64).sum::<u64>() / total_views
    } else {
        0
    };

    Ok(VideoAnalytics {
        total_views,
        total_unique_viewers,
        total_likes,
        total_completions,
        avg_watch_duration,
    })
}

// Structure to represent video analytics
#[derive(candid::CandidType, serde::Deserialize, Debug, Clone)]
pub struct VideoAnalytics {
    pub total_views: u64,
    pub total_unique_viewers: u64,
    pub total_likes: u64,
    pub total_completions: u64,
    pub avg_watch_duration: u64,
}

================
File: src/backend/src/comment.rs
================
use candid::{CandidType, Decode, Deserialize, Encode, Principal};
use ic_stable_structures::{storable::Bound, Storable};
use std::borrow::Cow;

const MAX_VALUE_SIZE: u32 = 2000; // Comments might be longer

#[derive(CandidType, Deserialize, Debug, Clone, PartialEq)]
pub struct Comment {
    pub commenter_principal: Principal,
    pub video_id: String,
    pub text: String,
    pub timestamp: u64,
}

impl Storable for Comment {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(self).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        Decode!(bytes.as_ref(), Self).unwrap()
    }

    const BOUND: Bound = Bound::Bounded {
        max_size: MAX_VALUE_SIZE,
        is_fixed_size: false,
    };
}

// Wrapper struct for Vec<Comment>
#[derive(CandidType, Deserialize, Debug, Clone, PartialEq)]
pub struct CommentList(pub Vec<Comment>);

impl Storable for CommentList {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(&self.0).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        Self(Decode!(bytes.as_ref(), Vec<Comment>).unwrap())
    }

    // A higher bound since this is a vector of comments
    const BOUND: Bound = Bound::Bounded {
        max_size: 20000,
        is_fixed_size: false,
    };
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::BTreeMap;

    #[test]
    fn test_comment_serialization() {
        // Create a test principal
        let principal_bytes = [
            10, 116, 101, 115, 116, 45, 112, 114, 105, 110, 99, 105, 112, 97, 108,
        ];
        let principal = Principal::from_slice(&principal_bytes);

        // Create a test comment
        let comment = Comment {
            commenter_principal: principal,
            video_id: "video123".to_string(),
            text: "This is a great video! I really enjoyed it and learned a lot.".to_string(),
            timestamp: 1234567890,
        };

        // Test to_bytes
        let bytes = comment.to_bytes();
        
        // Test from_bytes
        let deserialized_comment = Comment::from_bytes(bytes);
        
        // Verify they match
        assert_eq!(comment, deserialized_comment);
        
        // Verify specific fields
        assert_eq!(comment.commenter_principal, deserialized_comment.commenter_principal);
        assert_eq!(comment.video_id, deserialized_comment.video_id);
        assert_eq!(comment.text, deserialized_comment.text);
        assert_eq!(comment.timestamp, deserialized_comment.timestamp);
    }

    #[test]
    fn test_vec_comments_serialization() {
        // Create a test principal
        let principal_bytes = [
            10, 116, 101, 115, 116, 45, 112, 114, 105, 110, 99, 105, 112, 97, 108,
        ];
        let principal = Principal::from_slice(&principal_bytes);

        // Create a vector of test comments
        let comments = vec![
            Comment {
                commenter_principal: principal,
                video_id: "video123".to_string(),
                text: "This is a great video! I really enjoyed it and learned a lot.".to_string(),
                timestamp: 1234567890,
            },
            Comment {
                commenter_principal: principal,
                video_id: "video123".to_string(),
                text: "I have a question: how did you achieve that effect at 2:30?".to_string(),
                timestamp: 1234567891,
            },
        ];

        // Test to_bytes for vector
        let bytes = comments.to_bytes();
        
        // Test from_bytes for vector
        let deserialized_comments = Vec::<Comment>::from_bytes(bytes);
        
        // Verify they match
        assert_eq!(comments, deserialized_comments);
        assert_eq!(comments.len(), deserialized_comments.len());
        
        // Test storing in a BTreeMap
        let mut map = BTreeMap::new();
        map.insert("video123".to_string(), comments);
        
        // Verify we can add multiple comments to the same key
        let mut comments_for_video = map.get("video123".to_string()).unwrap().clone();
        comments_for_video.push(Comment {
            commenter_principal: principal,
            video_id: "video123".to_string(),
            text: "Thanks for the reply! That clarifies things.".to_string(),
            timestamp: 1234567892,
        });
        
        map.insert("video123".to_string(), comments_for_video);
        
        // Verify we have 3 comments now
        assert_eq!(map.get("video123".to_string()).unwrap().len(), 3);
        
        // Verify the chronological ordering
        let video_comments = map.get("video123".to_string()).unwrap();
        for i in 1..video_comments.len() {
            assert!(video_comments[i].timestamp > video_comments[i-1].timestamp);
        }
    }
}

================
File: src/backend/src/follow_relationship.rs
================
// Follow relationship module for ShawtyFormVideo
// Defines data structures for tracking user follows

use candid::{CandidType, Deserialize, Principal};
use ic_stable_structures::Storable;
use ic_stable_structures::storable::Bound;
use std::borrow::Cow;
use serde::Serialize;

/// Represents a follow relationship between two users
#[derive(CandidType, Deserialize, Serialize, Debug, Clone, PartialEq)]
pub struct FollowRelationship {
    pub follower_principal: Principal, // The user who is following
    pub followed_principal: Principal, // The user being followed
    pub timestamp: u64,                // When the follow action occurred
}

/// Collection wrapper to handle the Rust orphan rule
/// This allows implementing foreign traits (Storable) for a collection type
#[derive(CandidType, Deserialize, Debug, Clone, PartialEq)]
pub struct FollowRelationshipList(pub Vec<FollowRelationship>);

impl Storable for FollowRelationshipList {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(candid::encode_one(self).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        candid::decode_one(bytes.as_ref()).unwrap()
    }

    // Set the size bound for storage optimization
    const BOUND: Bound = Bound::Bounded {
        max_size: 10_000,
        is_fixed_size: false,
    };
}

================
File: src/backend/src/lib.rs
================
mod declarations;
mod service;
mod user_profile;
mod video_metadata;
mod watch_event;
mod tip_record;
mod comment;
mod follow_relationship;

use ic_stable_structures::memory_manager::{MemoryId, MemoryManager, VirtualMemory};
use ic_stable_structures::{DefaultMemoryImpl, StableBTreeMap};
use std::cell::RefCell;
use user_profile::UserProfile;
use video_metadata::VideoMetadata;
use watch_event::WatchEventList;
use tip_record::TipRecordList;
use comment::CommentList;
use follow_relationship::{FollowRelationship, FollowRelationshipList};

type Memory = VirtualMemory<DefaultMemoryImpl>;

thread_local! {
    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));

    static USER_PROFILES: RefCell<StableBTreeMap<String, UserProfile, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(0))),
        )
    );

    static VIDEOS: RefCell<StableBTreeMap<String, VideoMetadata, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(1))),
        )
    );

    static WATCH_LOG: RefCell<StableBTreeMap<String, WatchEventList, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(2))),
        )
    );

    static TIP_RECORDS: RefCell<StableBTreeMap<String, TipRecordList, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(3))),
        )
    );

    static COMMENTS: RefCell<StableBTreeMap<String, CommentList, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(4))),
        )
    );

    static FOLLOW_RELATIONSHIPS: RefCell<StableBTreeMap<String, FollowRelationshipList, Memory>> = RefCell::new(
        StableBTreeMap::init(
            MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(5))),
        )
    );
}

================
File: src/backend/src/tip_record.rs
================
use candid::{CandidType, Decode, Deserialize, Encode};
use ic_stable_structures::{storable::Bound, Storable};
use std::borrow::Cow;

const MAX_VALUE_SIZE: u32 = 500; // Should be sufficient for tip records

#[derive(CandidType, Deserialize, Debug, Clone, PartialEq)]
pub struct TipRecord {
    pub from_addr: String,
    pub to_addr: String,
    pub video_id: String,
    pub amount: u64,
    pub tx_hash: String,
    pub timestamp: u64,
}

impl Storable for TipRecord {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(self).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        Decode!(bytes.as_ref(), Self).unwrap()
    }

    const BOUND: Bound = Bound::Bounded {
        max_size: MAX_VALUE_SIZE,
        is_fixed_size: false,
    };
}

// Wrapper struct for Vec<TipRecord>
#[derive(CandidType, Deserialize, Debug, Clone, PartialEq)]
pub struct TipRecordList(pub Vec<TipRecord>);

impl Storable for TipRecordList {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(&self.0).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        Self(Decode!(bytes.as_ref(), Vec<TipRecord>).unwrap())
    }

    // A higher bound since this is a vector
    const BOUND: Bound = Bound::Bounded {
        max_size: 10000,
        is_fixed_size: false,
    };
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::BTreeMap;

    #[test]
    fn test_tip_record_serialization() {
        // Create a test tip record
        let tip = TipRecord {
            from_addr: "0x123456789abcdef0123456789abcdef012345678".to_string(),
            to_addr: "0xabcdef0123456789abcdef0123456789abcdef01".to_string(),
            video_id: "video123".to_string(),
            amount: 1000000000000000000, // 1 ETH in wei
            tx_hash: "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890".to_string(),
            timestamp: 1234567890,
        };

        // Test to_bytes
        let bytes = tip.to_bytes();
        
        // Test from_bytes
        let deserialized_tip = TipRecord::from_bytes(bytes);
        
        // Verify they match
        assert_eq!(tip, deserialized_tip);
        
        // Verify specific fields
        assert_eq!(tip.from_addr, deserialized_tip.from_addr);
        assert_eq!(tip.to_addr, deserialized_tip.to_addr);
        assert_eq!(tip.video_id, deserialized_tip.video_id);
        assert_eq!(tip.amount, deserialized_tip.amount);
        assert_eq!(tip.tx_hash, deserialized_tip.tx_hash);
        assert_eq!(tip.timestamp, deserialized_tip.timestamp);
    }

    #[test]
    fn test_vec_tip_records_serialization() {
        // Create a vector of test tip records
        let tips = vec![
            TipRecord {
                from_addr: "0x123456789abcdef0123456789abcdef012345678".to_string(),
                to_addr: "0xabcdef0123456789abcdef0123456789abcdef01".to_string(),
                video_id: "video123".to_string(),
                amount: 1000000000000000000, // 1 ETH in wei
                tx_hash: "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890".to_string(),
                timestamp: 1234567890,
            },
            TipRecord {
                from_addr: "0x123456789abcdef0123456789abcdef012345678".to_string(),
                to_addr: "0xabcdef0123456789abcdef0123456789abcdef01".to_string(),
                video_id: "video123".to_string(),
                amount: 500000000000000000, // 0.5 ETH in wei
                tx_hash: "0x9876543210fedcba9876543210fedcba9876543210fedcba9876543210fedcba".to_string(),
                timestamp: 1234567891,
            },
        ];

        // Test to_bytes for vector
        let bytes = tips.to_bytes();
        
        // Test from_bytes for vector
        let deserialized_tips = Vec::<TipRecord>::from_bytes(bytes);
        
        // Verify they match
        assert_eq!(tips, deserialized_tips);
        assert_eq!(tips.len(), deserialized_tips.len());
        
        // Test storing in a BTreeMap
        let mut map = BTreeMap::new();
        map.insert("video123".to_string(), tips);
        
        // Verify we can add multiple tips to the same key
        let mut tips_for_video = map.get("video123".to_string()).unwrap().clone();
        tips_for_video.push(TipRecord {
            from_addr: "0xfedcba9876543210fedcba9876543210fedcba98".to_string(),
            to_addr: "0xabcdef0123456789abcdef0123456789abcdef01".to_string(),
            video_id: "video123".to_string(),
            amount: 250000000000000000, // 0.25 ETH in wei
            tx_hash: "0x456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123".to_string(),
            timestamp: 1234567892,
        });
        
        map.insert("video123".to_string(), tips_for_video);
        
        // Verify we have 3 tips now
        assert_eq!(map.get("video123".to_string()).unwrap().len(), 3);
        
        // Verify the total amount tipped
        let total_amount: u64 = map
            .get("video123".to_string())
            .unwrap()
            .iter()
            .map(|tip| tip.amount)
            .sum();
        
        assert_eq!(total_amount, 1750000000000000000); // 1.75 ETH in wei
    }
}

================
File: src/backend/src/user_profile.rs
================
use candid::{CandidType, Decode, Deserialize, Encode};
use ic_stable_structures::{storable::Bound, Storable};
use std::borrow::Cow;

const MAX_VALUE_SIZE: u32 = 500;

#[derive(CandidType, Deserialize, Debug, Clone, PartialEq)]
pub struct UserProfile {
    pub evm_address: String,    // 0x..., from SIWE
    pub name: String,
    pub avatar_url: String,
}

impl Storable for UserProfile {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(self).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        Decode!(bytes.as_ref(), Self).unwrap()
    }

    const BOUND: Bound = Bound::Bounded {
        max_size: MAX_VALUE_SIZE,
        is_fixed_size: false,
    };
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialization() {
        let profile = UserProfile {
            evm_address: "0x123456789abcdef0123456789abcdef012345678".to_string(),
            name: "Test User".to_string(),
            avatar_url: "https://example.com/avatar.png".to_string(),
        };

        // Test to_bytes
        let bytes = profile.to_bytes();
        
        // Test from_bytes
        let deserialized_profile = UserProfile::from_bytes(bytes);
        
        // Verify they match
        assert_eq!(profile, deserialized_profile);
        
        // Specifically verify the EVM address was preserved correctly
        assert_eq!(profile.evm_address, deserialized_profile.evm_address);
    }
}

================
File: src/backend/src/video_metadata.rs
================
use candid::{CandidType, Decode, Deserialize, Encode, Principal};
use ic_stable_structures::{storable::Bound, Storable};
use std::borrow::Cow;

const MAX_VALUE_SIZE: u32 = 1000; // Increased for video metadata

#[derive(CandidType, Deserialize, Debug, Clone, PartialEq)]
pub struct VideoMetadata {
    pub video_id: String,
    pub uploader_principal: Principal,
    pub tags: Vec<String>,
    pub title: String,
    pub storage_ref: Option<String>, // Reference to chunk storage or IPFS
    pub timestamp: u64,
}

impl Storable for VideoMetadata {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(self).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        Decode!(bytes.as_ref(), Self).unwrap()
    }

    const BOUND: Bound = Bound::Bounded {
        max_size: MAX_VALUE_SIZE,
        is_fixed_size: false,
    };
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialization() {
        // Create a test principal
        let principal_bytes = [
            10, 116, 101, 115, 116, 45, 112, 114, 105, 110, 99, 105, 112, 97, 108,
        ];
        let principal = Principal::from_slice(&principal_bytes);

        // Create test video metadata
        let metadata = VideoMetadata {
            video_id: "video123".to_string(),
            uploader_principal: principal,
            tags: vec!["funny".to_string(), "short".to_string()],
            title: "Test Video".to_string(),
            storage_ref: Some("ipfs://QmTest123".to_string()),
            timestamp: 1234567890,
        };

        // Test to_bytes
        let bytes = metadata.to_bytes();
        
        // Test from_bytes
        let deserialized_metadata = VideoMetadata::from_bytes(bytes);
        
        // Verify they match
        assert_eq!(metadata, deserialized_metadata);
        
        // Verify specific fields
        assert_eq!(metadata.video_id, deserialized_metadata.video_id);
        assert_eq!(metadata.uploader_principal, deserialized_metadata.uploader_principal);
        assert_eq!(metadata.tags, deserialized_metadata.tags);
        assert_eq!(metadata.title, deserialized_metadata.title);
        assert_eq!(metadata.storage_ref, deserialized_metadata.storage_ref);
        assert_eq!(metadata.timestamp, deserialized_metadata.timestamp);
    }

    #[test]
    fn test_tags() {
        // Create a test principal
        let principal_bytes = [
            10, 116, 101, 115, 116, 45, 112, 114, 105, 110, 99, 105, 112, 97, 108,
        ];
        let principal = Principal::from_slice(&principal_bytes);

        // Create test video metadata with multiple tags
        let metadata = VideoMetadata {
            video_id: "video123".to_string(),
            uploader_principal: principal,
            tags: vec!["funny".to_string(), "short".to_string(), "trending".to_string()],
            title: "Test Video".to_string(),
            storage_ref: None,
            timestamp: 1234567890,
        };

        // Test to_bytes
        let bytes = metadata.to_bytes();
        
        // Test from_bytes
        let deserialized_metadata = VideoMetadata::from_bytes(bytes);
        
        // Verify tags specifically
        assert_eq!(metadata.tags, deserialized_metadata.tags);
        assert_eq!(metadata.tags.len(), 3);
        assert!(metadata.tags.contains(&"funny".to_string()));
        assert!(metadata.tags.contains(&"short".to_string()));
        assert!(metadata.tags.contains(&"trending".to_string()));
    }
}

================
File: src/backend/src/watch_event.rs
================
use candid::{CandidType, Decode, Deserialize, Encode, Principal};
use ic_stable_structures::{storable::Bound, Storable};
use std::borrow::Cow;

const MAX_VALUE_SIZE: u32 = 100; // Should be sufficient for watch events

#[derive(CandidType, Deserialize, Debug, Clone, PartialEq)]
pub struct WatchEvent {
    pub user_principal: Principal,
    pub video_id: String,
    pub watch_duration_sec: u32,
    pub liked: bool,
    pub completed: bool, 
    pub timestamp: u64,
}

impl Storable for WatchEvent {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(self).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        Decode!(bytes.as_ref(), Self).unwrap()
    }

    const BOUND: Bound = Bound::Bounded {
        max_size: MAX_VALUE_SIZE,
        is_fixed_size: false,
    };
}

// Wrapper struct for Vec<WatchEvent>
#[derive(CandidType, Deserialize, Debug, Clone, PartialEq)]
pub struct WatchEventList(pub Vec<WatchEvent>);

impl Storable for WatchEventList {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(&self.0).unwrap())
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        Self(Decode!(bytes.as_ref(), Vec<WatchEvent>).unwrap())
    }

    // A higher bound since this is a vector
    const BOUND: Bound = Bound::Bounded {
        max_size: 10000,
        is_fixed_size: false,
    };
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::BTreeMap;

    #[test]
    fn test_watch_event_serialization() {
        // Create a test principal
        let principal_bytes = [
            10, 116, 101, 115, 116, 45, 112, 114, 105, 110, 99, 105, 112, 97, 108,
        ];
        let principal = Principal::from_slice(&principal_bytes);

        // Create a test watch event
        let event = WatchEvent {
            user_principal: principal,
            video_id: "video123".to_string(),
            watch_duration_sec: 42,
            liked: true,
            completed: false,
            timestamp: 1234567890,
        };

        // Test to_bytes
        let bytes = event.to_bytes();
        
        // Test from_bytes
        let deserialized_event = WatchEvent::from_bytes(bytes);
        
        // Verify they match
        assert_eq!(event, deserialized_event);
        
        // Verify specific fields
        assert_eq!(event.user_principal, deserialized_event.user_principal);
        assert_eq!(event.video_id, deserialized_event.video_id);
        assert_eq!(event.watch_duration_sec, deserialized_event.watch_duration_sec);
        assert_eq!(event.liked, deserialized_event.liked);
        assert_eq!(event.completed, deserialized_event.completed);
        assert_eq!(event.timestamp, deserialized_event.timestamp);
    }

    #[test]
    fn test_vec_watch_events_serialization() {
        // Create a test principal
        let principal_bytes = [
            10, 116, 101, 115, 116, 45, 112, 114, 105, 110, 99, 105, 112, 97, 108,
        ];
        let principal = Principal::from_slice(&principal_bytes);

        // Create a vector of test watch events
        let events = vec![
            WatchEvent {
                user_principal: principal,
                video_id: "video123".to_string(),
                watch_duration_sec: 42,
                liked: true,
                completed: false,
                timestamp: 1234567890,
            },
            WatchEvent {
                user_principal: principal,
                video_id: "video456".to_string(),
                watch_duration_sec: 30,
                liked: false,
                completed: true,
                timestamp: 1234567891,
            },
        ];

        // Test to_bytes for vector
        let bytes = events.to_bytes();
        
        // Test from_bytes for vector
        let deserialized_events = Vec::<WatchEvent>::from_bytes(bytes);
        
        // Verify they match
        assert_eq!(events, deserialized_events);
        assert_eq!(events.len(), deserialized_events.len());
        
        // Test storing in a BTreeMap
        let mut map = BTreeMap::new();
        map.insert("video123".to_string(), events);
        
        // Verify we can add multiple events to the same key
        let mut events_for_video = map.get("video123".to_string()).unwrap().clone();
        events_for_video.push(WatchEvent {
            user_principal: principal,
            video_id: "video123".to_string(),
            watch_duration_sec: 15,
            liked: true,
            completed: true,
            timestamp: 1234567892,
        });
        
        map.insert("video123".to_string(), events_for_video);
        
        // Verify we have 3 events now
        assert_eq!(map.get("video123".to_string()).unwrap().len(), 3);
    }
}

================
File: src/backend/backend.did
================
type Name = text;
type AvatarUrl = text;
type VideoId = text;
type Title = text;
type Tag = text;
type StorageRef = text;
type Text = text;
type TxHash = text;
type Principal = principal;

// User Profile
type UserProfile = record {
  evm_address : text;
  name : text;
  avatar_url : text;
};

// Video Metadata
type VideoMetadata = record {
  video_id : text;
  uploader_principal : Principal;
  tags : vec Tag;
  title : text;
  storage_ref : opt StorageRef;
  timestamp : nat64;
};

// Watch Event
type WatchEvent = record {
  user_principal : Principal;
  video_id : text;
  watch_duration_sec : nat32;
  liked : bool;
  completed : bool;
  timestamp : nat64;
};

// Tip Record
type TipRecord = record {
  from_addr : text;
  to_addr : text;
  video_id : text;
  amount : nat64;
  tx_hash : text;
  timestamp : nat64;
};

// Comment
type Comment = record {
  commenter_principal : Principal;
  video_id : text;
  text : text;
  timestamp : nat64;
};

// Analytics
type VideoAnalytics = record {
  total_views : nat64;
  total_unique_viewers : nat64;
  total_likes : nat64;
  total_completions : nat64;
  avg_watch_duration : nat64;
};

// Response types
type GetMyProfileResponse = variant {
  Ok : UserProfile;
  Err : text;
};

type SaveMyProfileResponse = variant {
  Ok : UserProfile;
  Err : text;
};

type ListProfilesResponse = variant {
  Ok : vec record { text; UserProfile };
  Err : text;
};

type VideoMetadataResponse = variant {
  Ok : VideoMetadata;
  Err : text;
};

type CommentResponse = variant {
  Ok : Comment;
  Err : text;
};

type TipRecordResponse = variant {
  Ok : TipRecord;
  Err : text;
};

type EmptyResponse = variant {
  Ok;
  Err : text;
};

type VideoAnalyticsResponse = variant {
  Ok : VideoAnalytics;
  Err : text;
};

service : () -> {
  // User Profile
  "get_my_profile" : () -> (GetMyProfileResponse) query;
  "save_my_profile" : (Name, AvatarUrl) -> (SaveMyProfileResponse);
  "list_profiles" : () -> (ListProfilesResponse) query;
  
  // Video Metadata
  "create_video_metadata" : (VideoId, Title, vec Tag, opt StorageRef) -> (VideoMetadataResponse);
  "get_video_metadata" : (VideoId) -> (VideoMetadataResponse) query;
  "list_all_videos" : () -> (vec VideoMetadata) query;
  "list_videos_by_tag" : (Tag) -> (vec VideoMetadata) query;
  "list_videos_by_uploader" : (Principal) -> (vec VideoMetadata) query;
  "update_video_metadata" : (VideoId, opt Title, opt vec Tag, opt StorageRef) -> (VideoMetadataResponse);
  "delete_video" : (VideoId) -> (EmptyResponse);
  
  // Search
  "search_videos" : (text, opt nat32, opt nat32) -> (vec VideoMetadata) query;
  "search_videos_by_tags" : (vec text, opt nat32, opt nat32) -> (vec VideoMetadata) query;
  
  // Watch Events
  "log_watch_event" : (VideoId, nat32, bool, bool) -> (EmptyResponse);
  "get_watch_events" : (VideoId) -> (vec WatchEvent) query;
  "get_my_watch_events" : () -> (vec WatchEvent) query;
  "get_video_analytics" : (VideoId) -> (VideoAnalyticsResponse) query;
  
  // Tips
  "record_tip" : (VideoId, nat64, TxHash) -> (TipRecordResponse);
  "get_tips_for_video" : (VideoId) -> (vec TipRecord) query;
  "get_my_sent_tips" : () -> (vec TipRecord) query;
  "get_my_received_tips" : () -> (vec TipRecord) query;
  
  // Comments
  "post_comment" : (VideoId, Text) -> (CommentResponse);
  "get_comments" : (VideoId) -> (vec Comment) query;
  "get_my_comments" : () -> (vec Comment) query;
  "delete_comment" : (VideoId, nat64) -> (EmptyResponse);
  
  // Follows
  "follow_user" : (Principal) -> (EmptyResponse);
  "unfollow_user" : (Principal) -> (EmptyResponse);
  "get_followers" : (Principal) -> (vec Principal) query;
  "get_following" : (Principal) -> (vec Principal) query;
  "is_following" : (Principal, Principal) -> (bool) query;
};

================
File: src/backend/build.rs
================
use dotenv::dotenv;
use ic_cdk_bindgen::{Builder, Config};
use std::env;
use std::path::PathBuf;

/// This build script generates bindings in the declarations module to simplify interacting
/// with the deployed ic_siwe_provider canister.
fn main() {
    dotenv().ok();

    let manifest_dir =
        PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").expect("Cannot find manifest dir"));

    let ic_siwe_provider_did_path =
        manifest_dir.join("../ic_siwe_provider/declarations/ic_siwe_provider.did");

    let ic_siwe_provider_did_str = ic_siwe_provider_did_path.to_str().expect("Path invalid");

    unsafe {
        env::set_var(
            "CANISTER_CANDID_PATH_IC_SIWE_PROVIDER",
            ic_siwe_provider_did_str,
        )
    };

    let mut builder = Builder::new();

    // ic_siwe_provider
    let mut ic_siwe_provider = Config::new("ic_siwe_provider");
    ic_siwe_provider
        .binding
        .set_type_attributes("#[derive(Debug, CandidType, Deserialize)]".into());
    builder.add(ic_siwe_provider);

    builder.build(Some(manifest_dir.join("src/declarations")));
}

================
File: src/backend/Cargo.toml
================
[package]
name = "backend"
version = "0.0.1"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
candid = "0.10.10"
ic-cdk = "0.16.0"
serde = "1.0.208"
serde_json = "1.0.125"
ic-stable-structures = "0.6.5"
serde_bytes = "0.11.15"

[build-dependencies]
ic-cdk-bindgen = "0.1.3"
dotenv = "0.15.0"

================
File: src/frontend/public/ethereum.svg
================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="256px" height="417px" viewBox="0 0 256 417" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid">
	<g>
		<polygon fill="#343434" points="127.9611 0 125.1661 9.5 125.1661 285.168 127.9611 287.958 255.9231 212.32"/>
		<polygon fill="#8C8C8C" points="127.962 0 0 212.32 127.962 287.959 127.962 154.158"/>
		<polygon fill="#3C3C3B" points="127.9611 312.1866 126.3861 314.1066 126.3861 412.3056 127.9611 416.9066 255.9991 236.5866"/>
		<polygon fill="#8C8C8C" points="127.962 416.9052 127.962 312.1852 0 236.5852"/>
		<polygon fill="#141414" points="127.9611 287.9577 255.9211 212.3207 127.9611 154.1587"/>
		<polygon fill="#393939" points="0.0009 212.3208 127.9609 287.9578 127.9609 154.1588"/>
	</g>
</svg>

================
File: src/frontend/public/ic.svg
================
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 24.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 358.8 179.8" style="enable-background:new 0 0 358.8 179.8;" xml:space="preserve">
<style type="text/css">
	.st0{fill:url(#SVGID_1_);}
	.st1{fill:url(#SVGID_2_);}
	.st2{fill-rule:evenodd;clip-rule:evenodd;fill:#29ABE2;}
</style>
<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="224.7853" y1="257.7536" x2="348.0663" y2="133.4581" gradientTransform="matrix(1 0 0 -1 0 272)">
	<stop  offset="0.21" style="stop-color:#F15A24"/>
	<stop  offset="0.6841" style="stop-color:#FBB03B"/>
</linearGradient>
<path class="st0" d="M271.6,0c-20,0-41.9,10.9-65,32.4c-10.9,10.1-20.5,21.1-27.5,29.8c0,0,11.2,12.9,23.5,26.8
	c6.7-8.4,16.2-19.8,27.3-30.1c20.5-19.2,33.9-23.1,41.6-23.1c28.8,0,52.2,24.2,52.2,54.1c0,29.6-23.4,53.8-52.2,54.1
	c-1.4,0-3-0.2-5-0.6c8.4,3.9,17.5,6.7,26,6.7c52.8,0,63.2-36.5,63.8-39.1c1.5-6.7,2.4-13.7,2.4-20.9C358.6,40.4,319.6,0,271.6,0z"/>
<linearGradient id="SVGID_2_" gradientUnits="userSpaceOnUse" x1="133.9461" y1="106.4262" x2="10.6653" y2="230.7215" gradientTransform="matrix(1 0 0 -1 0 272)">
	<stop  offset="0.21" style="stop-color:#ED1E79"/>
	<stop  offset="0.8929" style="stop-color:#522785"/>
</linearGradient>
<path class="st1" d="M87.1,179.8c20,0,41.9-10.9,65-32.4c10.9-10.1,20.5-21.1,27.5-29.8c0,0-11.2-12.9-23.5-26.8
	c-6.7,8.4-16.2,19.8-27.3,30.1c-20.5,19-34,23.1-41.6,23.1c-28.8,0-52.2-24.2-52.2-54.1c0-29.6,23.4-53.8,52.2-54.1
	c1.4,0,3,0.2,5,0.6c-8.4-3.9-17.5-6.7-26-6.7C13.4,29.6,3,66.1,2.4,68.8C0.9,75.5,0,82.5,0,89.7C0,139.4,39,179.8,87.1,179.8z"/>
<path class="st2" d="M127.3,59.7c-5.8-5.6-34-28.5-61-29.3C18.1,29.2,4,64.2,2.7,68.7C12,29.5,46.4,0.2,87.2,0
	c33.3,0,67,32.7,91.9,62.2c0,0,0.1-0.1,0.1-0.1c0,0,11.2,12.9,23.5,26.8c0,0,14,16.5,28.8,31c5.8,5.6,33.9,28.2,60.9,29
	c49.5,1.4,63.2-35.6,63.9-38.4c-9.1,39.5-43.6,68.9-84.6,69.1c-33.3,0-67-32.7-92-62.2c0,0.1-0.1,0.1-0.1,0.2
	c0,0-11.2-12.9-23.5-26.8C156.2,90.8,142.2,74.2,127.3,59.7z M2.7,69.1c0-0.1,0-0.2,0.1-0.3C2.7,68.9,2.7,69,2.7,69.1z"/>
</svg>

================
File: src/frontend/public/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/frontend/public/siwe.svg
================
<svg class="w-37.5 h-65 md:mr-14 mb-4 md:mb-0" viewBox="0 0 149 260" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M112.957 115.649C112.595 115.649 112.24 115.552 111.93 115.367C111.619 115.182 111.364 114.916 111.192 114.598L94.8677 85.674C94.7083 85.4416 94.599 85.1787 94.5467 84.9019C94.4943 84.6252 94.4999 84.3406 94.5634 84.0661C94.6268 83.7916 94.7467 83.5334 94.9153 83.3076C95.0839 83.0818 95.2975 82.8935 95.5427 82.7545C95.7879 82.6155 96.0593 82.5288 96.3398 82.5001C96.6203 82.4714 96.9037 82.5012 97.172 82.5876C97.4404 82.674 97.6878 82.815 97.8987 83.002C98.1096 83.1889 98.2795 83.4175 98.3974 83.6734L114.722 112.631C114.854 112.862 114.938 113.117 114.97 113.381C115.002 113.645 114.981 113.912 114.909 114.168C114.836 114.424 114.713 114.662 114.547 114.87C114.381 115.078 114.175 115.25 113.941 115.378C113.648 115.565 113.305 115.66 112.957 115.649ZM143.401 149.388L116.724 193.842C116.665 193.967 116.585 194.082 116.487 194.181L76.337 258.132C76.1543 258.427 75.8994 258.669 75.5965 258.838C75.2936 259.006 74.9527 259.095 74.606 259.095C74.2594 259.095 73.9185 259.006 73.6155 258.838C73.3126 258.669 73.0577 258.427 72.8751 258.132L5.16669 150.269C1.86151 145.022 0.0741363 138.962 0.00225679 132.762C-0.0696227 126.562 1.57681 120.463 4.75944 115.14L72.8412 1.00471C73.0462 0.655761 73.3507 0.375778 73.7157 0.200586C74.0808 0.0253929 74.4898 -0.037047 74.8906 0.0211922C75.2913 0.0794314 75.6656 0.255709 75.9655 0.527542C76.2655 0.799375 76.4775 1.1544 76.5745 1.54724L143.774 115.039C146.89 120.241 148.504 126.204 148.438 132.266C148.372 138.328 146.629 144.254 143.401 149.388ZM88.9962 151.694L101.554 131.077C102.391 129.712 102.854 128.15 102.896 126.548C102.938 124.947 102.557 123.363 101.791 121.956L76.6424 79.74V92.7269L91.5756 118.803C92.6277 120.638 93.1728 122.72 93.1549 124.835C93.137 126.95 92.5568 129.023 91.4737 130.84L88.0798 136.503C87.8994 136.808 87.6408 137.06 87.3307 137.233C87.0206 137.406 86.67 137.493 86.315 137.486C85.9564 137.497 85.6023 137.403 85.2969 137.215C85.0644 137.082 84.861 136.904 84.6988 136.691C84.5365 136.478 84.4186 136.234 84.3522 135.975C84.2857 135.716 84.272 135.446 84.3118 135.181C84.3517 134.917 84.4443 134.663 84.5841 134.434L87.978 128.738C88.6891 127.545 89.0702 126.185 89.0821 124.797C89.094 123.408 88.7364 122.042 88.0459 120.837L76.6424 100.933V121.346C76.6302 129.438 79.0933 137.341 83.7017 143.996L88.9962 151.694ZM112.448 192.96L80.3417 146.302C75.2639 138.97 72.5519 130.262 72.5697 121.346V9.44791L8.25518 117.243C5.45647 121.918 4.0097 127.277 4.07561 132.724C4.14151 138.171 5.71754 143.493 8.62854 148.099L74.606 253.215L112.448 192.96ZM140.278 117.141L76.6424 9.65135V21.0107L116.08 90.5568C116.213 90.7883 116.3 91.0439 116.335 91.309C116.37 91.5741 116.352 91.8434 116.283 92.1017C116.214 92.3599 116.094 92.6019 115.931 92.8139C115.768 93.026 115.565 93.2038 115.333 93.3373C115.019 93.5061 114.671 93.599 114.315 93.6086C113.957 93.6088 113.606 93.5149 113.296 93.3363C112.986 93.1577 112.729 92.9008 112.55 92.5913L76.6424 29.2504V45.8655L94.4264 76.2475C94.5663 76.4757 94.6589 76.7297 94.6987 76.9943C94.7385 77.259 94.7249 77.5289 94.6584 77.7882C94.592 78.0475 94.4741 78.2908 94.3118 78.5037C94.1496 78.7167 93.9462 78.8949 93.7138 79.0279C93.4067 79.2124 93.0538 79.3065 92.6956 79.2992C92.3406 79.3064 91.99 79.2191 91.6799 79.0463C91.3698 78.8735 91.1113 78.6214 90.9308 78.3159L76.6424 53.9018V71.8733L105.287 119.888V119.955C106.399 122 106.956 124.299 106.902 126.625C106.849 128.951 106.186 131.223 104.982 133.214L91.4399 155.39L97.5149 164.172L116.181 133.756C117.335 131.857 118.998 128.161 116.962 124.703L115.299 121.82C115.165 121.589 115.078 121.333 115.043 121.068C115.008 120.803 115.026 120.534 115.095 120.275C115.165 120.017 115.284 119.775 115.447 119.563C115.61 119.351 115.814 119.173 116.046 119.04C116.516 118.779 117.069 118.711 117.588 118.85C118.108 118.989 118.553 119.325 118.829 119.786L120.492 122.634C122.732 126.534 122.46 131.349 119.643 135.892L100.026 167.834L106.271 176.888L129.961 138.673C131.314 136.478 132.051 133.959 132.093 131.381C132.134 128.803 131.48 126.262 130.198 124.024L116.962 101.035C116.692 100.567 116.619 100.011 116.759 99.4897C116.899 98.9683 117.241 98.5238 117.709 98.254C118.177 97.9842 118.733 97.9112 119.255 98.0511C119.777 98.191 120.222 98.5324 120.492 99L133.728 121.99C135.373 124.865 136.212 128.13 136.158 131.441C136.105 134.753 135.16 137.988 133.422 140.809L108.783 180.55L114.722 189.196L139.837 147.252C139.871 147.252 139.871 147.252 139.871 147.218C142.711 142.731 144.253 137.546 144.325 132.237C144.397 126.928 142.996 121.703 140.278 117.141Z" fill="url(#paint0_linear_2_477)"></path><defs><linearGradient id="paint0_linear_2_477" x1="61.0407" y1="39.6574" x2="1.19901" y2="306.127" gradientUnits="userSpaceOnUse"><stop offset="0.111821" stop-color="#04D2CA"></stop><stop offset="0.816463" stop-color="#6A49E4"></stop></linearGradient></defs></svg>

================
File: src/frontend/public/walletconnect.svg
================
<svg fill="none" height="400" viewBox="0 0 400 400" width="400" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><clipPath id="a"><path d="m0 0h400v400h-400z"/></clipPath><g clip-path="url(#a)"><circle cx="200" cy="200" fill="#3396ff" r="199.5" stroke="#66b1ff"/><path d="m122.519 148.965c42.791-41.729 112.171-41.729 154.962 0l5.15 5.022c2.14 2.086 2.14 5.469 0 7.555l-17.617 17.18c-1.07 1.043-2.804 1.043-3.874 0l-7.087-6.911c-29.853-29.111-78.253-29.111-108.106 0l-7.59 7.401c-1.07 1.043-2.804 1.043-3.874 0l-17.617-17.18c-2.14-2.086-2.14-5.469 0-7.555zm191.397 35.529 15.679 15.29c2.14 2.086 2.14 5.469 0 7.555l-70.7 68.944c-2.139 2.087-5.608 2.087-7.748 0l-50.178-48.931c-.535-.522-1.402-.522-1.937 0l-50.178 48.931c-2.139 2.087-5.608 2.087-7.748 0l-70.7015-68.945c-2.1396-2.086-2.1396-5.469 0-7.555l15.6795-15.29c2.1396-2.086 5.6085-2.086 7.7481 0l50.1789 48.932c.535.522 1.402.522 1.937 0l50.177-48.932c2.139-2.087 5.608-2.087 7.748 0l50.179 48.932c.535.522 1.402.522 1.937 0l50.179-48.931c2.139-2.087 5.608-2.087 7.748 0z" fill="#fff"/></g></svg>

================
File: src/frontend/src/assets/ic.svg
================
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 24.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 358.8 179.8" style="enable-background:new 0 0 358.8 179.8;" xml:space="preserve">
<style type="text/css">
	.st0{fill:url(#SVGID_1_);}
	.st1{fill:url(#SVGID_2_);}
	.st2{fill-rule:evenodd;clip-rule:evenodd;fill:#29ABE2;}
</style>
<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="224.7853" y1="257.7536" x2="348.0663" y2="133.4581" gradientTransform="matrix(1 0 0 -1 0 272)">
	<stop  offset="0.21" style="stop-color:#F15A24"/>
	<stop  offset="0.6841" style="stop-color:#FBB03B"/>
</linearGradient>
<path class="st0" d="M271.6,0c-20,0-41.9,10.9-65,32.4c-10.9,10.1-20.5,21.1-27.5,29.8c0,0,11.2,12.9,23.5,26.8
	c6.7-8.4,16.2-19.8,27.3-30.1c20.5-19.2,33.9-23.1,41.6-23.1c28.8,0,52.2,24.2,52.2,54.1c0,29.6-23.4,53.8-52.2,54.1
	c-1.4,0-3-0.2-5-0.6c8.4,3.9,17.5,6.7,26,6.7c52.8,0,63.2-36.5,63.8-39.1c1.5-6.7,2.4-13.7,2.4-20.9C358.6,40.4,319.6,0,271.6,0z"/>
<linearGradient id="SVGID_2_" gradientUnits="userSpaceOnUse" x1="133.9461" y1="106.4262" x2="10.6653" y2="230.7215" gradientTransform="matrix(1 0 0 -1 0 272)">
	<stop  offset="0.21" style="stop-color:#ED1E79"/>
	<stop  offset="0.8929" style="stop-color:#522785"/>
</linearGradient>
<path class="st1" d="M87.1,179.8c20,0,41.9-10.9,65-32.4c10.9-10.1,20.5-21.1,27.5-29.8c0,0-11.2-12.9-23.5-26.8
	c-6.7,8.4-16.2,19.8-27.3,30.1c-20.5,19-34,23.1-41.6,23.1c-28.8,0-52.2-24.2-52.2-54.1c0-29.6,23.4-53.8,52.2-54.1
	c1.4,0,3,0.2,5,0.6c-8.4-3.9-17.5-6.7-26-6.7C13.4,29.6,3,66.1,2.4,68.8C0.9,75.5,0,82.5,0,89.7C0,139.4,39,179.8,87.1,179.8z"/>
<path class="st2" d="M127.3,59.7c-5.8-5.6-34-28.5-61-29.3C18.1,29.2,4,64.2,2.7,68.7C12,29.5,46.4,0.2,87.2,0
	c33.3,0,67,32.7,91.9,62.2c0,0,0.1-0.1,0.1-0.1c0,0,11.2,12.9,23.5,26.8c0,0,14,16.5,28.8,31c5.8,5.6,33.9,28.2,60.9,29
	c49.5,1.4,63.2-35.6,63.9-38.4c-9.1,39.5-43.6,68.9-84.6,69.1c-33.3,0-67-32.7-92-62.2c0,0.1-0.1,0.1-0.1,0.2
	c0,0-11.2-12.9-23.5-26.8C156.2,90.8,142.2,74.2,127.3,59.7z M2.7,69.1c0-0.1,0-0.2,0.1-0.3C2.7,68.9,2.7,69,2.7,69.1z"/>
</svg>

================
File: src/frontend/src/cdp/CustomFundWallet.tsx
================
import { FundButton, getOnrampBuyUrl } from '@coinbase/onchainkit/fund';
import { useAccount } from 'wagmi';
import { twMerge } from 'tailwind-merge';

interface CustomFundWalletProps {
  className?: string;
  presetAmount?: number;
}

export function CustomFundWallet({ 
  className = '', 
  presetAmount = 50
}: CustomFundWalletProps) {
  const { address } = useAccount();
  
  if (!address) {
    return <div className={twMerge("text-white", className)}>Please connect wallet first.</div>;
  }

  // Create a custom onramp URL to buy USDC on Base
  const onrampBuyUrl = getOnrampBuyUrl({
    projectId: import.meta.env.VITE_PUBLIC_CDP_PROJECT_ID!,
    addresses: { [address]: ['base'] },
    assets: ['USDC'],
    presetFiatAmount: presetAmount,
    fiatCurrency: 'USD',
  });

  return (
    <div className={twMerge("flex justify-center", className)}>
      <FundButton 
        fundingUrl={onrampBuyUrl} 
        openIn="popup"
      />
    </div>
  );
}

================
File: src/frontend/src/cdp/FundWallet.tsx
================
import { FundButton } from '@coinbase/onchainkit/fund';
import { ConnectWallet, Wallet } from '@coinbase/onchainkit/wallet';
import { useAccount } from 'wagmi';
import { twMerge } from 'tailwind-merge';

interface FundWalletProps {
  className?: string;
}

export function FundWallet({ className = '' }: FundWalletProps) {
  const { address } = useAccount();

  if (!address) {
    return (
      <Wallet>
        <ConnectWallet>Connect to Fund</ConnectWallet>
      </Wallet>
    );
  }

  return (
    <div className={twMerge("flex justify-center", className)}>
      <FundButton />
    </div>
  );
}

================
File: src/frontend/src/cdp/index.ts
================
export * from './OnchainKitProvider';
export * from './FundWallet';
export * from './CustomFundWallet';

================
File: src/frontend/src/cdp/OnchainKitProvider.tsx
================
import { ReactNode } from 'react';
import { OnchainKitProvider } from '@coinbase/onchainkit';
import { base } from 'viem/chains';

interface AppOnchainKitProviderProps {
  children: ReactNode;
}

export function AppOnchainKitProvider({ children }: AppOnchainKitProviderProps) {
  return (
    <OnchainKitProvider
      apiKey={import.meta.env.VITE_PUBLIC_ONCHAINKIT_API_KEY}
      chain={base}
      projectId={import.meta.env.VITE_PUBLIC_CDP_PROJECT_ID}
      config={{
        appearance: {
          name: 'ShawtyFormVideo',
          mode: 'auto',
          theme: 'default',
        },
      }}
    >
      {children}
    </OnchainKitProvider>
  );
}

================
File: src/frontend/src/components/header/EthButton.tsx
================
import { useAccount, useEnsName } from "wagmi";

import { AccountDialog } from "../AccountDialog";
import Button from "../ui/Button";
import ConnectDialog from "../ConnectDialog";
import { faEthereum } from "@fortawesome/free-brands-svg-icons";
import { faWaveSquare } from "@fortawesome/free-solid-svg-icons";
import { shortenEthAddress } from "../../eth/utils/shortenEthAddress";
import { useState } from "react";

export default function EthButton() {
  const { address, isConnected, isConnecting } = useAccount();
  const [connectDialogOpen, setConnectDialogOpen] = useState(false);
  const [accountDialogOpen, setAccountDialogOpen] = useState(false);
  const { data: ensName } = useEnsName({
    address: address as `0x${string}`,
    chainId: 1,
  });

  const handleClick = () => {
    if (isConnected) {
      setAccountDialogOpen(true);
    } else {
      setConnectDialogOpen(true);
    }
  };

  const buttonIcon = () => {
    if (isConnecting) {
      return faWaveSquare;
    } else if (isConnected) {
      return faEthereum;
    } else {
      return faWaveSquare;
    }
  };

  const buttonText = () => {
    if (isConnecting) {
      return "Connecting...";
    }
    if (isConnected) {
      return ensName ?? shortenEthAddress(address);
    }
    return "Connect";
  };

  return (
    <>
      <Button icon={buttonIcon()} onClick={handleClick} variant="dark">
        {buttonText()}
      </Button>
      <ConnectDialog
        isOpen={connectDialogOpen}
        setIsOpen={setConnectDialogOpen}
      />
      <AccountDialog
        isOpen={accountDialogOpen}
        setIsOpen={setAccountDialogOpen}
      />
    </>
  );
}

================
File: src/frontend/src/components/header/Header.tsx
================
import EthButton from "./EthButton";
import IdentityButton from "./IdentityButton";
import SessionButton from "./SessionButton";

export default function Header() {
  return (
    <div className="flex flex-col justify-between w-full gap-10 p-5 md:flex-row">
      <div className="hidden text-xl font-bold text-center md:block">
        Internet Computer + React + Sign In With Ethereum
      </div>
      <div className="flex flex-col items-center justify-center gap-5 text-sm md:text-base md:flex-row">
        <IdentityButton />
        <EthButton />
        <SessionButton />
      </div>
      <div className="block text-xl font-bold text-center md:hidden">
        Internet Computer + React + Sign In With Ethereum
      </div>
    </div>
  );
}

================
File: src/frontend/src/components/header/IdentityButton.tsx
================
import Button from "../ui/Button";
import PrincipalDialog from "./PrincipalDialog";
import { useAccount } from "wagmi";
import { useSiwe } from "ic-siwe-js/react";
import { useState } from "react";

export default function IdentityButton() {
  const { identity } = useSiwe();
  const { isConnected } = useAccount();

  const [isOpen, setIsOpen] = useState(false);

  if (!identity || !isConnected) return null;

  let principal = identity.getPrincipal().toString();
  principal = principal.slice(0, 6) + "..." + principal.slice(-4);

  return (
    <>
      <Button
        className="whitespace-nowrap"
        onClick={() => setIsOpen(true)}
        variant="dark"
      >
        <img
          alt="Internet Computer"
          className="inline-block w-4 h-4 mr-1 "
          src="/ic.svg"
        />
        {principal}
      </Button>
      <PrincipalDialog isOpen={isOpen} setIsOpen={setIsOpen} />
    </>
  );
}

================
File: src/frontend/src/components/header/PrincipalDialog.tsx
================
import Button from "../ui/Button";
import Dialog from "../ui/Dialog";
import { Dialog as HeadlessDialog } from "@headlessui/react";
import { useSiwe } from "ic-siwe-js/react";

export default function PrincipalDialog({
  isOpen,
  setIsOpen,
}: {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
}) {
  const { clear, identity } = useSiwe();

  if (!identity) return null;

  return (
    <Dialog className="max-w-xl" isOpen={isOpen} setIsOpen={setIsOpen}>
      <img
        alt="Internet Computer"
        className="inline-block w-12 h-12"
        src="/ic.svg"
      />
      <HeadlessDialog.Title>Internet Computer Identity</HeadlessDialog.Title>
      <div className="px-4 py-2 text-xs rounded-lg text-zinc-400 bg-zinc-900/50">
        <code className="md:whitespace-nowrap">
          {identity?.getPrincipal().toString()}
        </code>
      </div>
      <div className="flex justify-center w-full gap-5">
        <Button onClick={() => setIsOpen(false)} variant="outline">
          Close
        </Button>
        <Button onClick={clear}>Logout</Button>
      </div>
    </Dialog>
  );
}

================
File: src/frontend/src/components/header/SessionButton.tsx
================
import Button from "../ui/Button";
import SessionDialog from "./SessionDialog";
import { faUser } from "@fortawesome/free-solid-svg-icons";
import { useState } from "react";

export default function SessionButton() {
  // Local state
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <Button
        className="hidden w-10 h-10 rounded-full md:flex"
        icon={faUser}
        onClick={() => setIsOpen(true)}
        variant="dark"
      ></Button>
      <Button
        className="md:hidden"
        icon={faUser}
        onClick={() => setIsOpen(true)}
        variant="dark"
      >
        User profile
      </Button>
      <SessionDialog isOpen={isOpen} setIsOpen={setIsOpen} />
    </>
  );
}

================
File: src/frontend/src/components/header/SessionDialog.tsx
================
import Button from "../ui/Button";
import Dialog from "../ui/Dialog";
import EditProfile from "../profile/EditProfile";
import { Dialog as HeadlessDialog } from "@headlessui/react";
import { useSiwe } from "ic-siwe-js/react";

type SessionDialogProps = {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
};

function arrayBufferToHex(arrayBuffer: ArrayBuffer): string {
  const byteArray = new Uint8Array(arrayBuffer);
  return Array.from(byteArray, (byte) =>
    byte.toString(16).padStart(2, "0"),
  ).join("");
}

export default function SessionDialog({
  isOpen,
  setIsOpen,
}: SessionDialogProps) {
  const { clear, identity, delegationChain } = useSiwe();

  if (!identity) return null;

  return (
    <Dialog className="max-w-xl" isOpen={isOpen} setIsOpen={setIsOpen}>
      <HeadlessDialog.Title>Session</HeadlessDialog.Title>
      <div className="px-4 py-2 text-xs rounded-lg text-zinc-400 bg-zinc-900/50">
        <pre>
          {delegationChain?.delegations.map((delegation) => {
            const pubKey = arrayBufferToHex(delegation.delegation.pubkey);
            const expiration = new Date(
              Number(delegation.delegation.expiration / 1000000n),
            );
            return (
              <div key={pubKey}>
                pubkey: {pubKey.slice(0, 8)}...{pubKey.slice(-8)}
                <br />
                expiration: {expiration.toLocaleDateString()}{" "}
                {expiration.toLocaleTimeString()}
                <br />
              </div>
            );
          })}
        </pre>
      </div>
      <EditProfile
        allwaysShow
        className="w-full max-w-2xl border-zinc-700/50 border-[1px] bg-zinc-900 drop-shadow-xl rounded-3xl flex flex-col items-center p-8"
      />

      <div className="flex justify-center w-full gap-5">
        <Button onClick={() => setIsOpen(false)} variant="outline">
          Close
        </Button>
        <Button onClick={clear}>Logout</Button>
      </div>
    </Dialog>
  );
}

================
File: src/frontend/src/components/layout/DesktopLayout.tsx
================
import { useState } from 'react';
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { 
  faHome, faCompass, faUsers, faUpload, 
  faVideo, faCoins, faUser, faEllipsisH,
  faTimes
} from "@fortawesome/free-solid-svg-icons";
import AddressPill from '../AddressPill';
import { useAccount } from 'wagmi';
import Button from '../ui/Button';
import { AccountDialog } from '../AccountDialog';
import { VideoFeed, VideoUpload } from '../../livepeer';
import { useSiwe } from 'ic-siwe-js/react';
import { VideoViewPage } from '../video/VideoViewPage';
import { VideoGrid } from '../video/VideoGrid';
import { SimpleSearch } from '../search/SimpleSearch';

interface DesktopLayoutProps {
  onLoginClick: () => void;
  isAuthenticated: boolean;
}

// Grid item component for internal use only
// Will be replaced by the VideoGrid component

export default function DesktopLayout({ onLoginClick, isAuthenticated }: DesktopLayoutProps) {
  const [activeTab, setActiveTab] = useState("All");
  const [showAccountDialog, setShowAccountDialog] = useState(false);
  const [showUploadModal, setShowUploadModal] = useState(false);
  const [activeView, setActiveView] = useState<'grid' | 'feed' | 'view' | 'search'>('grid');
  const [selectedVideoTag, setSelectedVideoTag] = useState<string | undefined>(undefined);
  const [selectedVideoId, setSelectedVideoId] = useState<string | null>(null);
  const { address } = useAccount();
  const { identity } = useSiwe();

  const navLinks = [
    { 
      label: "For You", 
      icon: faHome, 
      onClick: () => {
        setActiveView('feed');
        setSelectedVideoTag(undefined);
        setSelectedVideoId(null);
      }
    },
    { 
      label: "Explore", 
      icon: faCompass,
      onClick: () => {
        setActiveView('grid');
        setSelectedVideoTag(undefined);
        setSelectedVideoId(null);
      }
    },
    { label: "Following", icon: faUsers },
    { 
      label: "Upload", 
      icon: faUpload,
      onClick: () => {
        if (identity) {
          setShowUploadModal(true);
        } else {
          onLoginClick();
        }
      }
    },
    { label: "LIVE", icon: faVideo },
    { label: "Get Coins", icon: faCoins },
    { label: "Profile", icon: faUser },
    { label: "More", icon: faEllipsisH },
  ];

  const categoryTabs = [
    "All", "Singing & Dancing", "Comedy", "Sports", "Anime & Comics", 
    "Relationship", "Shows", "Lipsync", "Daily Life", "Beauty Care", 
    "Games", "Society", "Outfit", "Cars"
  ];

  // Dummy videos have been removed - now using real data from backend
  
  // Handle category tab click
  const handleTabClick = (tab: string) => {
    setActiveTab(tab);
    // Filter by tag for both feed and grid views
    if (tab !== 'All') {
      setSelectedVideoTag(tab.toLowerCase());
    } else {
      setSelectedVideoTag(undefined);
    }
    
    // If we're in video view, go back to grid/feed
    if (activeView === 'view') {
      setActiveView('grid');
      setSelectedVideoId(null);
    }
  };

  const handleUploadComplete = () => {
    setShowUploadModal(false);
    // Switch to the feed view to see the newly uploaded videos
    setActiveView('feed');
  };
  
  return (
    <div className="flex w-full h-screen text-white">
      {/* Left Sidebar */}
      <div className="flex flex-col w-64 h-full p-4 border-r border-zinc-700 bg-zinc-850">
        <div className="flex items-center justify-center h-12 mb-6">
          <span className="text-2xl font-bold">SweetSwoot</span>
        </div>
        
        <nav className="flex-grow mb-6 space-y-2">
          {navLinks.map(link => (
            <div 
              key={link.label}
              className="flex items-center gap-3 px-4 py-3 transition-colors rounded-lg cursor-pointer hover:bg-zinc-700"
              onClick={link.onClick}
            >
              <FontAwesomeIcon icon={link.icon} />
              <span>{link.label}</span>
            </div>
          ))}
        </nav>
        
        {isAuthenticated ? (
          <div onClick={() => setShowAccountDialog(true)} className="cursor-pointer">
            <AddressPill address={address || ""} className="w-full bg-zinc-700" />
          </div>
        ) : (
          <Button 
            variant="primary" 
            className="w-full py-3"
            onClick={onLoginClick}
          >
            Log in
          </Button>
        )}
        
        <div className="pt-6 mt-6 text-xs text-zinc-500 border-t border-zinc-700">
          <div className="flex flex-wrap gap-2 mb-2">
            <span className="cursor-pointer hover:underline">Company</span>
            <span className="cursor-pointer hover:underline">Program</span>
            <span className="cursor-pointer hover:underline">Terms & Policies</span>
          </div>
          <span>© 2025 SweetSwoot</span>
        </div>
      </div>
      
      {/* Main Content */}
      <div className="flex-grow h-full overflow-y-auto">
        {/* Search Button */}
        <div className="sticky top-0 z-10 flex items-center justify-center p-4 bg-zinc-900">
          <div className="w-full max-w-md">
            <button 
              onClick={() => setActiveView('search')} 
              className="w-full px-4 py-2 text-left text-zinc-400 bg-zinc-800 rounded-full focus:outline-none hover:bg-zinc-700"
            >
              Search videos...
            </button>
          </div>
        </div>
        
        {/* Category Tabs */}
        <div className="sticky top-16 z-10 flex px-4 py-2 space-x-4 overflow-x-auto bg-zinc-900">
          {categoryTabs.map(tab => (
            <button
              key={tab}
              className={`px-4 py-2 text-sm rounded-full whitespace-nowrap ${
                activeTab === tab 
                  ? "bg-zinc-700 text-white" 
                  : "bg-transparent text-zinc-400 hover:bg-zinc-800"
              }`}
              onClick={() => handleTabClick(tab)}
            >
              {tab}
            </button>
          ))}
        </div>
        
        {/* View Selector Buttons */}
        <div className="flex items-center justify-center p-4 space-x-4">
          <button
            onClick={() => setActiveView('grid')}
            className={`px-4 py-2 rounded-lg transition-colors ${
              activeView === 'grid' 
                ? 'bg-blue-600 text-white' 
                : 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
            }`}
          >
            Grid View
          </button>
          <button
            onClick={() => setActiveView('feed')}
            className={`px-4 py-2 rounded-lg transition-colors ${
              activeView === 'feed' 
                ? 'bg-blue-600 text-white' 
                : 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
            }`}
          >
            Feed View
          </button>
        </div>
        
        {/* Content Area */}
        <div className="p-4 h-[calc(100vh-146px)]">
          {activeView === 'search' ? (
            <SimpleSearch />
          ) : activeView === 'view' && selectedVideoId ? (
            <div className="h-full">
              <div className="mb-4">
                <button
                  onClick={() => {
                    // Return to previous view
                    setActiveView(activeView === 'view' ? 'grid' : activeView);
                    setSelectedVideoId(null);
                  }}
                  className="flex items-center text-blue-400 hover:text-blue-300 transition-colors"
                >
                  <FontAwesomeIcon icon={faHome} className="mr-2" />
                  <span>Back to videos</span>
                </button>
              </div>
              <VideoViewPage videoId={selectedVideoId} />
            </div>
          ) : activeView === 'grid' ? (
            <VideoGrid 
              tag={activeTab === "All" ? undefined : activeTab}
              onVideoSelect={(videoId) => {
                setSelectedVideoId(videoId);
                setActiveView('view');
              }}
              className="bg-zinc-900"
            />
          ) : (
            <VideoFeed 
              tag={selectedVideoTag}
              className="h-full rounded-lg overflow-hidden"
              onVideoSelect={(videoId) => {
                setSelectedVideoId(videoId);
                setActiveView('view');
              }}
            />
          )}
        </div>
      </div>

      {/* Account Dialog */}
      {showAccountDialog && (
        <AccountDialog isOpen={showAccountDialog} setIsOpen={setShowAccountDialog} />
      )}
      
      {/* Upload Modal */}
      {showUploadModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70">
          <div className="relative w-full max-w-xl p-1 bg-zinc-900 rounded-xl">
            <button 
              onClick={() => setShowUploadModal(false)}
              className="absolute p-2 text-white bg-zinc-800 rounded-full -top-3 -right-3 hover:bg-zinc-700"
            >
              <FontAwesomeIcon icon={faTimes} />
            </button>
            <VideoUpload onUploadComplete={handleUploadComplete} />
          </div>
        </div>
      )}
    </div>
  );
}

================
File: src/frontend/src/components/layout/MobileLayout.tsx
================
import { useState } from 'react';
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { 
  faHome, faCompass, faPlus, 
  faUser, faBars, faTimes
} from "@fortawesome/free-solid-svg-icons";
import Button from '../ui/Button';
import { AccountDialog } from '../AccountDialog';
import { VideoFeed, VideoUpload } from '../../livepeer';
import { useSiwe } from 'ic-siwe-js/react';
import { SimpleSearch } from '../search/SimpleSearch';

interface MobileLayoutProps {
  onLoginClick: () => void;
  isAuthenticated: boolean;
}

// Simple mobile VideoCard component
const VideoCard = ({ caption, user, views, onClick }: { 
  caption: string;
  user: string;
  views: string;
  onClick?: () => void;
}) => {
  return (
    <div 
      className="flex flex-col bg-zinc-800 rounded-lg overflow-hidden"
      onClick={onClick}
    >
      <div className="aspect-[9/16] bg-zinc-700 flex items-center justify-center">
        <span className="text-xs text-center px-2 text-zinc-500">{caption}</span>
      </div>
      <div className="p-2">
        <p className="text-sm font-medium truncate">{user}</p>
        <p className="text-xs text-zinc-400">{views} views</p>
      </div>
    </div>
  );
};

export default function MobileLayout({ onLoginClick, isAuthenticated }: MobileLayoutProps) {
  const [showAccountDialog, setShowAccountDialog] = useState(false);
  const [showUploadModal, setShowUploadModal] = useState(false);
  const [activeView, setActiveView] = useState<'grid' | 'feed' | 'search'>('grid');
  const { identity } = useSiwe();
  
  // Sample video data for grid view
  const dummyVideos = [
    { user: "ellaonwheels_0", views: "18.5M", caption: "Short clip of a micro car at night" },
    { user: "vexbolts", views: "3M", caption: "Person in a suit discussing 2025 milestone" },
    { user: "mrbeast", views: "16.1M", caption: "\"I'm Buying TikTok\" text overlay" },
    { user: "street_art888", views: "13.2M", caption: "Optical illusion square hole table" },
    { user: "squidgamenetflix", views: "16.2M", caption: "Clip of someone dancing in Squid Game outfit" },
    { user: "jamieandblake", views: "5.2M", caption: "Couple in a store; comedic reaction" },
  ];

  const handleUploadComplete = () => {
    setShowUploadModal(false);
    // Switch to the feed view to see the newly uploaded videos
    setActiveView('feed');
  };
  
  return (
    <div className="flex flex-col w-full min-h-screen text-white">
      {/* Mobile Header */}
      <div className="sticky top-0 z-20 flex items-center justify-between p-4 bg-zinc-900">
        <button className="p-2">
          <FontAwesomeIcon icon={faBars} />
        </button>
        
        <div className="flex-grow mx-4">
          <button 
            onClick={() => setActiveView('search')} 
            className="w-full px-4 py-2 text-left text-sm text-zinc-400 bg-zinc-800 rounded-full focus:outline-none"
          >
            Search videos...
          </button>
        </div>

        {isAuthenticated ? (
          <div onClick={() => setShowAccountDialog(true)} className="cursor-pointer">
            <div className="w-8 h-8 bg-zinc-700 rounded-full"></div>
          </div>
        ) : (
          <Button
            variant="primary"
            className="px-3 py-1 text-sm"
            onClick={onLoginClick}
          >
            Log in
          </Button>
        )}
      </div>
      
      {/* View Selector Buttons */}
      <div className="flex items-center justify-center p-2 space-x-4 bg-zinc-900">
        <button
          onClick={() => setActiveView('grid')}
          className={`px-3 py-1 text-sm rounded-lg transition-colors ${
            activeView === 'grid' 
              ? 'bg-blue-600 text-white' 
              : 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
          }`}
        >
          Grid
        </button>
        <button
          onClick={() => setActiveView('feed')}
          className={`px-3 py-1 text-sm rounded-lg transition-colors ${
            activeView === 'feed' 
              ? 'bg-blue-600 text-white' 
              : 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
          }`}
        >
          Feed
        </button>
      </div>
      
      {/* Content Area */}
      {activeView === 'search' ? (
        <div className="flex-grow">
          <SimpleSearch />
        </div>
      ) : activeView === 'grid' ? (
        <div className="flex-grow grid grid-cols-2 gap-3 p-3">
          {dummyVideos.map((video, index) => (
            <VideoCard 
              key={index}
              caption={video.caption}
              user={video.user}
              views={video.views}
              onClick={() => {
                setActiveView('feed');
              }}
            />
          ))}
        </div>
      ) : (
        <div className="flex-grow">
          <VideoFeed 
            className="h-[calc(100vh-128px)]"
          />
        </div>
      )}
      
      {/* Bottom Navigation */}
      <div className="sticky bottom-0 z-10 flex items-center justify-around p-3 bg-zinc-900 border-t border-zinc-800">
        <button 
          className="flex flex-col items-center text-zinc-400 active:text-white"
          onClick={() => setActiveView('feed')}
        >
          <FontAwesomeIcon icon={faHome} className="text-lg" />
          <span className="mt-1 text-xs">Home</span>
        </button>
        
        <button 
          className="flex flex-col items-center text-zinc-400 active:text-white"
          onClick={() => setActiveView('grid')}
        >
          <FontAwesomeIcon icon={faCompass} className="text-lg" />
          <span className="mt-1 text-xs">Discover</span>
        </button>
        
        <button 
          className="flex flex-col items-center text-zinc-400 active:text-white"
          onClick={() => {
            if (identity) {
              setShowUploadModal(true);
            } else {
              onLoginClick();
            }
          }}
        >
          <div className="flex items-center justify-center w-12 h-12 rounded-full bg-gradient-to-r from-blue-500 to-purple-500">
            <FontAwesomeIcon icon={faPlus} className="text-xl text-white" />
          </div>
        </button>
        
        <button className="flex flex-col items-center text-zinc-400 active:text-white">
          <FontAwesomeIcon icon={faUser} className="text-lg" />
          <span className="mt-1 text-xs">Profile</span>
        </button>
      </div>
      
      {/* Account Dialog */}
      {showAccountDialog && (
        <AccountDialog isOpen={showAccountDialog} setIsOpen={setShowAccountDialog} />
      )}
      
      {/* Upload Modal */}
      {showUploadModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70">
          <div className="relative w-full max-w-lg mx-4 bg-zinc-900 rounded-xl">
            <button 
              onClick={() => setShowUploadModal(false)}
              className="absolute p-2 text-white bg-zinc-800 rounded-full -top-3 -right-3 hover:bg-zinc-700"
            >
              <FontAwesomeIcon icon={faTimes} />
            </button>
            <VideoUpload onUploadComplete={handleUploadComplete} />
          </div>
        </div>
      )}
    </div>
  );
}

================
File: src/frontend/src/components/login/ConnectButton.tsx
================
import Button from "../ui/Button";
import ConnectDialog from "../ConnectDialog";
import { faCircleNotch } from "@fortawesome/free-solid-svg-icons";
import { faEthereum } from "@fortawesome/free-brands-svg-icons";
import { useAccount } from "wagmi";
import { useState } from "react";

export default function ConnectButton() {
  const { isConnecting } = useAccount();
  const [connectDialogOpen, setConnectDialogOpen] = useState(false);

  const handleClick = () => {
    if (isConnecting) return;
    setConnectDialogOpen(true);
  };

  const buttonIcon = isConnecting ? faCircleNotch : faEthereum;

  const buttonText = isConnecting ? "Connecting" : "Connect wallet";

  return (
    <>
      <Button
        className="w-44"
        disabled={isConnecting}
        icon={buttonIcon}
        onClick={handleClick}
        spin={isConnecting}
      >
        {buttonText}
      </Button>
      <ConnectDialog
        isOpen={connectDialogOpen}
        setIsOpen={setConnectDialogOpen}
      />
    </>
  );
}

================
File: src/frontend/src/components/login/LoginButton.tsx
================
import { useAccount, useChainId } from "wagmi";

import Button from "../ui/Button";
import { faCircleNotch } from "@fortawesome/free-solid-svg-icons";
import { isChainIdSupported } from "../../wagmi/is-chain-id-supported";
import { useSiwe } from "ic-siwe-js/react";

interface LoginButtonProps {
  className?: string;
}

export default function LoginButton({ className = "w-44" }: LoginButtonProps) {
  const { isConnected } = useAccount();
  const chainId = useChainId();
  const { login, isLoggingIn, isPreparingLogin } = useSiwe();

  const text = () => {
    if (isLoggingIn) {
      return "Signing in";
    }
    if (isPreparingLogin) {
      return "Preparing";
    }
    return "Sign in";
  };

  const icon = isLoggingIn || isPreparingLogin ? faCircleNotch : undefined;

  const disabled =
    !isChainIdSupported(chainId) ||
    isLoggingIn ||
    !isConnected ||
    isPreparingLogin;

  return (
    <Button
      className={className}
      disabled={disabled}
      icon={icon}
      onClick={login}
      spin
    >
      {text()}
    </Button>
  );
}

================
File: src/frontend/src/components/login/LoginPage.tsx
================
import AddressPill from "../AddressPill";
import Button from "../ui/Button";
import ConnectButton from "./ConnectButton";
import LoginButton from "./LoginButton";
import { faWaveSquare, faChevronLeft } from "@fortawesome/free-solid-svg-icons";
import { isChainIdSupported } from "../../wagmi/is-chain-id-supported";
import toast from "react-hot-toast";
import { useAccount } from "wagmi";
import { useChainId } from "wagmi";
import { useEffect } from "react";
import { useSiwe } from "ic-siwe-js/react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";

interface LoginPageProps {
  onLoginComplete?: () => void;
}

export default function LoginPage({ onLoginComplete }: LoginPageProps): React.ReactElement {
  const { isConnected, address } = useAccount();
  const chainId = useChainId();
  const { loginError, identity } = useSiwe();
  const isAuthenticated = !!identity;

  /**
   * Show an error toast if the login call fails.
   */
  useEffect(() => {
    if (loginError) {
      toast.error(loginError.message, {
        position: "bottom-right",
      });
    }
  }, [loginError]);

  /**
   * Return to main page after successful login
   */
  useEffect(() => {
    if (isAuthenticated && onLoginComplete) {
      onLoginComplete();
    }
  }, [isAuthenticated, onLoginComplete]);

  return (
    <div className="flex flex-col items-center justify-center w-full min-h-screen p-4 bg-zinc-900 text-zinc-100">
      {/* Back button */}
      {onLoginComplete && (
        <button 
          onClick={onLoginComplete} 
          className="absolute flex items-center gap-2 p-2 text-sm top-4 left-4 text-zinc-400 hover:text-white"
        >
          <FontAwesomeIcon icon={faChevronLeft} />
          <span>Back</span>
        </button>
      )}
      
      <div className="flex items-center justify-center gap-5 md:gap-20 mb-8">
        <img alt="ic" className="w-16 h-16 md:w-24 md:h-24" src="/ic.svg" />
        <img alt="siwe" className="w-16 h-16 md:w-24 md:h-24" src="/siwe.svg" />
      </div>
      
      <div className="px-6 mb-10 text-xl font-bold text-center md:text-3xl">
        Sign In With Ethereum
      </div>
      
      <div className="w-80 md:w-96 border-zinc-700/50 border-[1px] bg-zinc-800 drop-shadow-xl rounded-2xl flex flex-col items-center py-5 px-5 mx-5">
        <div className="flex flex-col items-center w-full gap-8 p-6">
          <div className="flex items-center justify-center w-full gap-5">
            <div className="flex items-center justify-center w-8 h-8 text-lg font-bold rounded-full bg-zinc-300 text-zinc-800">
              1
            </div>
            <div className="flex-1">
              {!isConnected && <ConnectButton />}
              {isConnected && isChainIdSupported(chainId) && (
                <AddressPill
                  address={address}
                  className="justify-center w-full"
                />
              )}
              {isConnected && !isChainIdSupported(chainId) && (
                <Button disabled icon={faWaveSquare} variant="outline">
                  Unsupported Network
                </Button>
              )}
            </div>
          </div>
          
          <div className="flex items-center justify-center w-full gap-5">
            <div className="flex items-center justify-center w-8 h-8 text-lg font-bold rounded-full bg-zinc-300 text-zinc-800">
              2
            </div>
            <div className="flex-1">
              <LoginButton className="w-full" />
            </div>
          </div>
        </div>
      </div>
      
      <p className="mt-6 text-sm text-zinc-500">
        Connect your wallet and sign the message to verify ownership
      </p>
    </div>
  );
}

================
File: src/frontend/src/components/profile/AllProfiles.tsx
================
import { useEffect, useState } from "react";

import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import ProfileCard from "./ProfileCard";
import { UserProfile } from "../../../../backend/declarations/backend.did";
import { faCircleNotch } from "@fortawesome/free-solid-svg-icons";
import { useActor } from "../../ic/Actors";

export default function AllProfiles() {
  const [profiles, setProfiles] = useState<[string, UserProfile][]>([]);
  const [loading, setLoading] = useState(true);
  const actor = useActor();

  useEffect(() => {
    if (!actor) return;
    (async () => {
      // @ts-ignore - Handled by our proxy
      const response = await actor.list_profiles();
      if (response && "Ok" in response) {
        setProfiles(response.Ok);
      }
      setLoading(false);
    })();
  }, [actor]);

  return (
    <div className="w-full max-w-2xl border-zinc-700/50 border-[1px] bg-zinc-900 px-5 py-5 drop-shadow-xl rounded-3xl flex flex-col items-center">
      <div className="flex flex-col items-center w-full gap-10 py-8 md:px-8">
        <div className="text-2xl font-bold">User Profiles</div>
        <div className="flex flex-col items-center gap-5">
          {loading && (
            <div className="flex flex-col items-center justify-center w-full h-64">
              <FontAwesomeIcon className="w-4 h-4" icon={faCircleNotch} spin />
            </div>
          )}
          <div className="grid grid-cols-1 gap-5 md:grid-cols-3">
            {profiles.map((p) => (
              <ProfileCard key={p[0]} principal={p[0]} profile={p[1]} />
            ))}
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/frontend/src/components/profile/EditProfile.tsx
================
import { FormEvent, useEffect, useState } from "react";

import Button from "../ui/Button";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faCircleNotch } from "@fortawesome/free-solid-svg-icons";
import toast from "react-hot-toast";
import { useActor } from "../../ic/Actors";
import { CustomFundWallet } from "../../cdp/CustomFundWallet";

type EditProfileProps = {
  className?: string;
  allwaysShow?: boolean;
};

export default function EditProfile({
  className,
  allwaysShow,
}: EditProfileProps) {
  const actor = useActor();

  // Local state
  const [name, setName] = useState("");
  const [avatarUrl, setAvatarUrl] = useState("");
  const [hasProfile, setHasProfile] = useState(true);
  const [saving, setSaving] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    (async () => {
      if (!actor) return;
      // @ts-ignore - Handled by our proxy
      const response = await actor.get_my_profile();
      if (response && "Ok" in response) {
        setName(response.Ok.name);
        setAvatarUrl(response.Ok.avatar_url);
        if (response.Ok.name === "No Name") {
          setHasProfile(false);
        }
      } else {
        setHasProfile(false);
      }
      setLoading(false);
    })();
  }, [actor]);

  // Don't render if we already have a profile unless allwaysShow is true
  if (hasProfile && !allwaysShow) return null;

  // Don't render form when loading profile
  if (loading)
    return (
      <div className={className}>
        <div className="flex flex-col items-center w-full gap-5 h-72">
          <div className="text-2xl font-bold">User Profile</div>
          <div className="flex flex-col items-center justify-center w-full h-full">
            <FontAwesomeIcon className="w-4 h-4" icon={faCircleNotch} spin />
          </div>
        </div>
      </div>
    );

  async function submit(event: FormEvent<HTMLFormElement>) {
    event.preventDefault();
    if (!actor) return;
    setSaving(true);
    // @ts-ignore - Handled by our proxy
    const response = await actor.save_my_profile(name, avatarUrl);

    if (response && "Ok" in response) {
      toast.success("Profile saved");
      setTimeout(() => {
        window.location.reload();
      }, 1000);
    } else {
      if (response && "Err" in response) console.error(response.Err);
      toast.error("Error saving profile");
    }
    setSaving(false);
  }

  const submitIcon = saving ? faCircleNotch : undefined;

  const submitText = saving ? "Saving" : "Save";

  const submitDisabled = saving || !name;

  return (
    <div className={className}>
      <div className="flex flex-col items-center w-full gap-5">
        <div className="text-2xl font-bold">User Profile</div>
        <form
          className="flex flex-col items-center w-full gap-5"
          onSubmit={submit}
        >
          <div className="flex flex-col items-center w-full gap-3">
            <label htmlFor="name">What do you want to be called?</label>
            <input
              className="w-full px-3 py-2 leading-tight border rounded appearance-none text-zinc-500 focus:outline-none focus:bg-emerald-200 bg-slate-200"
              name="name"
              onChange={(e) => setName(e.target.value)}
              placeholder="Name"
              type="text"
              value={name}
            />
          </div>
          <div className="flex flex-col items-center w-full gap-3">
            <label htmlFor="name">Paste a link to your avatar (optional)</label>
            <input
              className="w-full px-3 py-2 leading-tight border rounded appearance-none text-zinc-500 focus:outline-none focus:bg-emerald-200 bg-slate-200"
              name="avatar_url"
              onChange={(e) => setAvatarUrl(e.target.value)}
              placeholder="https://example.com/avatar.png"
              type="text"
              value={avatarUrl}
            />
          </div>
          <Button
            className="w-full mt-5"
            disabled={submitDisabled}
            icon={submitIcon}
            spin
            type="submit"
            variant="primary"
          >
            {submitText}
          </Button>
        </form>

        <div className="w-full mt-8 border-t pt-6">
          <h3 className="text-xl font-semibold mb-4 text-center">Fund Your Wallet</h3>
          <p className="text-gray-600 dark:text-gray-400 mb-4 text-center">
            Need to add funds to your wallet to tip creators?
          </p>
          <CustomFundWallet />
        </div>
      </div>
    </div>
  );
}

================
File: src/frontend/src/components/profile/FollowSection.tsx
================
import { useState, useEffect } from 'react';
import { Principal } from '@dfinity/principal';
import { useActor } from '../../ic/Actors';
import { BackendExtended, UserProfile } from '../../livepeer/types';
import { twMerge } from 'tailwind-merge';
import { FollowButton } from '../ui/FollowButton';
import { useSiwe } from 'ic-siwe-js/react';

type TabType = 'followers' | 'following';

interface FollowSectionProps {
  userPrincipal: Principal;
  initialTab?: TabType;
  className?: string;
  onProfileClick?: (profile: UserProfile) => void;
}

export function FollowSection({
  userPrincipal,
  initialTab = 'followers',
  className = '',
  onProfileClick
}: FollowSectionProps) {
  const actor = useActor();
  const { identity } = useSiwe();
  const [activeTab, setActiveTab] = useState<TabType>(initialTab);
  const [followers, setFollowers] = useState<Principal[]>([]);
  const [following, setFollowing] = useState<Principal[]>([]);
  const [followerProfiles, setFollowerProfiles] = useState<UserProfile[]>([]);
  const [followingProfiles, setFollowingProfiles] = useState<UserProfile[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [loadingError, setLoadingError] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  
  // Fetch followers and following data
  useEffect(() => {
    const fetchFollowData = async () => {
      if (!actor || !userPrincipal) return;
      
      setIsLoading(true);
      setLoadingError(null);
      
      try {
        const backendActor = actor as unknown as BackendExtended;
        
        // Fetch followers and following in parallel
        const [followersList, followingList] = await Promise.all([
          backendActor.getFollowers(userPrincipal),
          backendActor.getFollowing(userPrincipal)
        ]);
        
        setFollowers(followersList);
        setFollowing(followingList);
        
        // Fetch all profiles and map them to followers/following
        try {
          const profilesResult = await backendActor.listProfiles();
          if ('Ok' in profilesResult) {
            const profiles = profilesResult.Ok.map(([_, profile]: [string, UserProfile]) => ({
              ...profile,
              principal: _ // Store the principal as a property for reference
            }));
            
            // Map principals to profile data for followers
            const followerProfilesData = profiles.filter(
              (profile: UserProfile) => followersList.some(
                f => f.toString() === profile.principal
              )
            );
            
            // Map principals to profile data for following
            const followingProfilesData = profiles.filter(
              (profile: UserProfile) => followingList.some(
                f => f.toString() === profile.principal
              )
            );
            
            setFollowerProfiles(followerProfilesData);
            setFollowingProfiles(followingProfilesData);
          } else {
            throw new Error('Failed to fetch profiles');
          }
        } catch (err) {
          console.error("Error fetching profile data:", err);
          setLoadingError("Couldn't load profile information");
        }
      } catch (err) {
        console.error("Error fetching follow data:", err);
        setLoadingError("Failed to load followers/following data");
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchFollowData();
  }, [actor, userPrincipal]);
  
  // Filter profiles based on search query
  const filteredProfiles = (activeTab === 'followers' ? followerProfiles : followingProfiles)
    .filter(profile => 
      profile.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      profile.evm_address.toLowerCase().includes(searchQuery.toLowerCase())
    );
  
  // Handle profile click
  const handleProfileClick = (profile: UserProfile) => {
    if (onProfileClick) {
      onProfileClick(profile);
    }
  };
  
  // Handle follow state change
  const handleFollowStateChange = (profile: UserProfile, isFollowing: boolean) => {
    // This is where we could update a global state or context if needed
    console.log(`${profile.name} is now ${isFollowing ? 'followed' : 'unfollowed'}`);
  };
  
  return (
    <div className={twMerge("bg-white dark:bg-gray-800 rounded-lg shadow-sm overflow-hidden", className)}>
      {/* Tabs */}
      <div className="flex border-b dark:border-gray-700">
        <button
          className={twMerge(
            "flex-1 py-3 px-4 text-center font-medium transition-colors",
            activeTab === 'followers'
              ? "text-blue-600 dark:text-blue-400 border-b-2 border-blue-600 dark:border-blue-400"
              : "text-gray-600 dark:text-gray-400 hover:text-blue-500 dark:hover:text-blue-300"
          )}
          onClick={() => setActiveTab('followers')}
        >
          Followers ({followers.length})
        </button>
        <button
          className={twMerge(
            "flex-1 py-3 px-4 text-center font-medium transition-colors",
            activeTab === 'following'
              ? "text-blue-600 dark:text-blue-400 border-b-2 border-blue-600 dark:border-blue-400"
              : "text-gray-600 dark:text-gray-400 hover:text-blue-500 dark:hover:text-blue-300"
          )}
          onClick={() => setActiveTab('following')}
        >
          Following ({following.length})
        </button>
      </div>
      
      {/* Search bar */}
      <div className="p-4 border-b dark:border-gray-700">
        <input
          type="text"
          placeholder="Search by name or address"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="w-full px-3 py-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400"
        />
      </div>
      
      {/* Content area */}
      <div className="max-h-96 overflow-y-auto">
        {isLoading ? (
          // Loading skeletons
          <div className="p-4 space-y-4">
            {[1, 2, 3].map(i => (
              <div key={i} className="flex items-center gap-3 animate-pulse">
                <div className="w-12 h-12 rounded-full bg-gray-300 dark:bg-gray-600"></div>
                <div className="flex-1">
                  <div className="h-4 bg-gray-300 dark:bg-gray-600 rounded w-1/3 mb-2"></div>
                  <div className="h-3 bg-gray-300 dark:bg-gray-600 rounded w-1/2"></div>
                </div>
                <div className="w-20 h-8 bg-gray-300 dark:bg-gray-600 rounded-full"></div>
              </div>
            ))}
          </div>
        ) : loadingError ? (
          // Error state
          <div className="p-8 text-center">
            <p className="text-red-500 dark:text-red-400 mb-2">{loadingError}</p>
            <button 
              className="text-blue-600 dark:text-blue-400 text-sm" 
              onClick={() => window.location.reload()}
            >
              Try reloading
            </button>
          </div>
        ) : filteredProfiles.length > 0 ? (
          // Profile list
          <ul className="divide-y dark:divide-gray-700">
            {filteredProfiles.map(profile => (
              <li key={profile.principal} className="p-4 hover:bg-gray-50 dark:hover:bg-gray-750 transition-colors">
                <div className="flex items-center gap-3">
                  {/* Avatar */}
                  <div 
                    className="w-12 h-12 rounded-full bg-gray-200 dark:bg-gray-700 overflow-hidden cursor-pointer"
                    onClick={() => handleProfileClick(profile)}
                  >
                    {profile.avatar_url ? (
                      <img 
                        src={profile.avatar_url} 
                        alt={profile.name} 
                        className="w-full h-full object-cover"
                      />
                    ) : (
                      <div className="w-full h-full flex items-center justify-center text-gray-500 dark:text-gray-400 text-xl font-medium">
                        {profile.name?.[0]?.toUpperCase() || '?'}
                      </div>
                    )}
                  </div>
                  
                  {/* User info */}
                  <div 
                    className="flex-1 cursor-pointer"
                    onClick={() => handleProfileClick(profile)}
                  >
                    <h3 className="font-medium">{profile.name}</h3>
                    <p className="text-sm text-gray-500 dark:text-gray-400">
                      {profile.evm_address.substring(0, 6)}...{profile.evm_address.substring(profile.evm_address.length - 4)}
                    </p>
                  </div>
                  
                  {/* Follow button - only show if we're authenticated and not our own profile */}
                  {identity && profile.principal !== identity.getPrincipal().toString() && (
                    <FollowButton 
                      userPrincipal={Principal.fromText(profile.principal as string)}
                      size="sm"
                      onFollowStateChange={(isFollowing) => handleFollowStateChange(profile, isFollowing)}
                    />
                  )}
                </div>
              </li>
            ))}
          </ul>
        ) : (
          // Empty state
          <div className="p-12 text-center">
            <p className="text-gray-500 dark:text-gray-400">
              {activeTab === 'followers' 
                ? "No followers yet" 
                : "Not following anyone yet"}
            </p>
            {activeTab === 'following' && (
              <p className="mt-2 text-sm text-gray-500 dark:text-gray-400">
                Follow other users to see them here
              </p>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

================
File: src/frontend/src/components/profile/NoProfileMessage.tsx
================
import { useEffect, useState } from "react";

import { useActor } from "../../ic/Actors";
import { useAccount } from "wagmi";
import AddressPill from "../AddressPill";
import PrincipalPill from "../PrincipalPill";
import { useSiwe } from "ic-siwe-js/react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faLeftRight } from "@fortawesome/free-solid-svg-icons";

export function NoProfileMessage() {
  const actor = useActor();
  const { address } = useAccount();
  const { identity } = useSiwe();

  // Local state
  const [hasProfile, setHasProfile] = useState(true);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    (async () => {
      if (!actor) return;
      // @ts-ignore - Handled by our proxy
      const response = await actor.get_my_profile();
      if (response && "Ok" in response) {
        if (response.Ok.name === "No Name") {
          setHasProfile(false);
        }
      } else {
        setHasProfile(false);
      }
      setLoading(false);
    })();
  }, [actor]);

  if (loading || hasProfile) return null;

  return (
    <div className="w-full max-w-2xl border-emerald-700/50 border-[1px] bg-emerald-900/50 px-5 py-5 drop-shadow-xl rounded-3xl flex flex-col items-center">
      <div className="flex flex-col items-center w-full gap-10 py-8 md:px-8">
        <div className="text-2xl font-bold">Welcome!</div>
        <div className="text-lg leading-loose text-center">
          You are logged in and have established a one to one link between your
          Ethereum address and your Internet Computer identity.
        </div>
        <div>
          <AddressPill
            address={address}
            className="inline-block bg-emerald-800"
          />
          <FontAwesomeIcon
            className="w-5 h-5 mx-3 text-emerald-500"
            icon={faLeftRight}
          />
          <PrincipalPill
            className="inline-block bg-emerald-800 "
            principal={identity?.getPrincipal().toString()}
          />
        </div>
        <div className="text-lg">Now, save your user profile!</div>
      </div>
    </div>
  );
}

================
File: src/frontend/src/components/profile/ProfileCard.tsx
================
import AddressPill from "../AddressPill";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import PrincipalPill from "../PrincipalPill";
import { UserProfile } from "../../../../backend/declarations/backend.did";
import { faUser } from "@fortawesome/free-solid-svg-icons";
import { useState } from "react";
import { FundWallet } from "../../cdp/FundWallet";

type ProfileCardProps = {
  principal: string;
  profile: UserProfile;
};

export default function ProfileCard({ principal, profile }: ProfileCardProps) {
  const [imageError, setImageError] = useState(false);

  const handleImageError = () => {
    setImageError(true);
  };

  return (
    <div className="flex flex-col items-center gap-5 p-5 border w-44 rounded-xl border-zinc-700 bg-zinc-800">
      {profile.avatar_url && !imageError ? (
        <img
          alt="avatar"
          className="w-20 h-20 border-[1px] rounded-full border-zinc-400/50 object-cover"
          onError={handleImageError}
          src={profile.avatar_url}
        />
      ) : (
        <div className="w-20 h-20 border-[1px] rounded-full border-zinc-400/50 flex justify-center items-center">
          <FontAwesomeIcon
            className="w-10 h-10 text-zinc-400/50"
            icon={faUser}
          />
        </div>
      )}
      <div className="w-32 font-bold text-center overflow-clip whitespace-nowrap overflow-ellipsis">
        {profile.name}
      </div>
      <PrincipalPill className="w-full bg-zinc-700" principal={principal} />
      <AddressPill address={profile.evm_address} className="w-full bg-zinc-700" />
      <FundWallet className="w-full mt-2" />
    </div>
  );
}

================
File: src/frontend/src/components/search/index.ts
================
export * from './SearchBar';
export * from './SearchResults';

================
File: src/frontend/src/components/search/SearchBar.tsx
================
import React from 'react';
import { useSearch } from '../../context/SearchContext';

interface SearchBarProps {
  className?: string;
}

export const SearchBar: React.FC<SearchBarProps> = ({ className = '' }) => {
  const { searchQuery, setSearchQuery, performSearch, clearSearch } = useSearch();
  
  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    performSearch();
  };
  
  return (
    <form onSubmit={handleSearch} className={`flex items-center ${className}`}>
      <input
        type="text"
        placeholder="Search videos..."
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        className="px-4 py-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-2 focus:ring-blue-500 flex-grow"
      />
      <button
        type="submit"
        className="px-4 py-2 bg-blue-500 text-white rounded-r-md hover:bg-blue-600"
      >
        Search
      </button>
      {searchQuery && (
        <button
          type="button"
          onClick={clearSearch}
          className="ml-2 px-2 py-2 text-gray-500 hover:text-gray-700"
        >
          Clear
        </button>
      )}
    </form>
  );
};

================
File: src/frontend/src/components/search/SearchResults.tsx
================
import React from 'react';
import { useSearch } from '../../context/SearchContext';
import { VideoPlayer } from '../../livepeer';
// Define Tag type locally
type Tag = string;

export const SearchResults: React.FC = () => {
  const { searchResults, isSearching, searchQuery } = useSearch();
  
  if (isSearching) {
    return <div className="p-4 text-center">Searching...</div>;
  }
  
  if (searchQuery && searchResults.length === 0) {
    return <div className="p-4 text-center">No videos found matching "{searchQuery}"</div>;
  }
  
  if (!searchQuery || searchResults.length === 0) {
    return null;
  }
  
  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4">Search Results for "{searchQuery}"</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {searchResults.map((video) => (
          <div key={video.video_id} className="border rounded-lg overflow-hidden">
            <VideoPlayer 
              videoId={video.video_id}
            />
            <div className="p-3">
              <h3 className="font-semibold">{video.title}</h3>
              <div className="flex flex-wrap gap-1 mt-2">
                {video.tags.map((tag: Tag) => (
                  <span key={tag} className="px-2 py-1 bg-gray-100 text-xs rounded-full">
                    {tag}
                  </span>
                ))}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

================
File: src/frontend/src/components/search/SimpleSearch.tsx
================
import { useState, useEffect } from 'react';
import { useActor } from '../../ic/Actors';

interface VideoMetadata {
  video_id: string;
  title: string;
  uploader_principal: any;
  tags: string[];
  storage_ref: string[] | [];
  timestamp: bigint;
}

/**
 * A standalone search component that doesn't rely on context
 */
export function SimpleSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<VideoMetadata[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const actor = useActor();

  // Perform search when query changes
  useEffect(() => {
    const search = async () => {
      if (!query || !actor) return;
      
      setIsSearching(true);
      try {
        // Cast actor to any to bypass TypeScript checking
        const backendActor = actor as any;
        
        if (typeof backendActor.search_videos === 'function') {
          const searchResults = await backendActor.search_videos(
            query,
            [20], // limit to 20 results
            [0]   // start at offset 0
          );
          setResults(searchResults);
        } else {
          console.error('search_videos function not found on actor');
          setResults([]);
        }
      } catch (error) {
        console.error('Search failed:', error);
        setResults([]);
      } finally {
        setIsSearching(false);
      }
    };

    // Debounce search
    const timer = setTimeout(() => {
      search();
    }, 500);

    return () => clearTimeout(timer);
  }, [query, actor]);

  return (
    <div className="p-4">
      <div className="mb-4">
        <input
          type="text"
          placeholder="Search videos..."
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          className="w-full px-4 py-2 bg-zinc-800 border border-zinc-700 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-500 text-white"
        />
      </div>

      {isSearching ? (
        <div className="py-8 text-center text-zinc-400">
          Searching...
        </div>
      ) : results.length > 0 ? (
        <div>
          <h2 className="text-xl font-semibold mb-4">Search Results</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {results.map((video) => (
              <div key={video.video_id} className="bg-zinc-800 rounded-lg overflow-hidden">
                <div className="aspect-video bg-zinc-700 flex items-center justify-center">
                  {video.storage_ref && video.storage_ref.length > 0 ? (
                    <div className="text-sm text-zinc-400 p-2">
                      Video ID: {video.video_id}
                    </div>
                  ) : (
                    <div className="text-sm text-zinc-400">No video reference</div>
                  )}
                </div>
                <div className="p-3">
                  <h3 className="font-semibold text-white">{video.title}</h3>
                  <div className="flex flex-wrap gap-1 mt-2">
                    {video.tags.map((tag, index) => (
                      <span key={index} className="px-2 py-1 bg-zinc-700 text-xs rounded-full text-zinc-300">
                        {tag}
                      </span>
                    ))}
                  </div>
                  <div className="mt-2 text-xs text-zinc-400">
                    Uploaded: {new Date(Number(video.timestamp) * 1000).toLocaleDateString()}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      ) : query ? (
        <div className="py-8 text-center text-zinc-400">
          No videos found matching "{query}"
        </div>
      ) : null}
    </div>
  );
}

================
File: src/frontend/src/components/ui/Button.tsx
================
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { IconDefinition } from "@fortawesome/free-solid-svg-icons";
import { twMerge } from "tailwind-merge";

type Variant = "primary" | "secondary" | "outline" | "dark";

type ButtonProps = {
  variant?: Variant;
  onClick?: () => void;
  className?: string;
  icon?: IconDefinition;
  iconClassName?: string;
  children?: React.ReactNode;
  spin?: boolean;
  disabled?: boolean;
  type?: "button" | "submit" | "reset";
};

export default function Button({
  variant,
  onClick,
  className,
  icon,
  iconClassName,
  children,
  spin,
  disabled,
  type,
}: ButtonProps) {
  className = twMerge(
    `flex rounded-xl px-4 py-2 items-center gap-2 drop-shadow-lg hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:scale-100 justify-center`,
    className
  );
  iconClassName = twMerge("w-4 h-4", iconClassName);

  className = {
    primary: twMerge(
      "bg-emerald-800 hover:bg-emerald-700 disabled:bg-emerald-800",
      className
    ),
    secondary: twMerge(
      "bg-amber-800 hover:bg-amber-700 disabled:bg-amber-800",
      className
    ),
    outline: twMerge(
      "bg-transparent border border-zinc-500 hover:bg-emerald-500/10 disabled:bg-transparent disabled:border-zinc-500",
      className
    ),
    dark: twMerge(
      "bg-zinc-900 hover:bg-zinc-950 disabled:bg-zinc-900",
      className
    ),
  }[variant || "primary"];

  return (
    <button
      className={className}
      disabled={disabled}
      onClick={onClick}
      type={type}
    >
      {icon && (
        <FontAwesomeIcon className={iconClassName} icon={icon} spin={spin} />
      )}
      {children}
    </button>
  );
}

================
File: src/frontend/src/components/ui/Dialog.tsx
================
import { useEffect, useState } from "react";

import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { Dialog as HeadlessDialog } from "@headlessui/react";
import { faXmark } from "@fortawesome/free-solid-svg-icons";
import { twMerge } from "tailwind-merge";

type DialogProps = {
  className?: string;
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  children: React.ReactNode;
};

export default function Dialog({
  className,
  isOpen,
  setIsOpen,
  children,
}: DialogProps) {
  const [animate, setAnimate] = useState(false);

  useEffect(() => {
    if (isOpen) {
      setAnimate(true);
    } else {
      const timer = setTimeout(() => setAnimate(false), 300);
      return () => clearTimeout(timer);
    }
  }, [isOpen]);

  className = twMerge(
    "w-full max-w-xl border-zinc-700/50 border-[1px] bg-zinc-800 px-5 drop-shadow-xl rounded-3xl flex flex-col items-center relative transform transition-transform ease-out duration-300",
    className
  );
  className += animate ? " translate-y-0" : " translate-y-full";

  return (
    <HeadlessDialog
      className="fixed inset-0 z-10 overflow-y-auto"
      onClose={() => setIsOpen(false)}
      open={isOpen}
    >
      <div className="fixed inset-0 flex w-screen items-center justify-center p-4 bg-[#00000070]">
        <HeadlessDialog.Panel className={className}>
          <div className="absolute right-5 top-5">
            <button onClick={() => setIsOpen(false)}>
              <FontAwesomeIcon
                className="w-3 h-3 p-2 bg-transparent border rounded-full border-zinc-500/50 hover:scale-105 text-zinc-500 hover:bg-emerald-500/10 hover:text-zinc-200"
                icon={faXmark}
              />
            </button>
          </div>
          <div className="flex flex-col items-center w-full gap-5 py-8 md:px-8">
            {children}
          </div>
        </HeadlessDialog.Panel>
      </div>
    </HeadlessDialog>
  );
}

================
File: src/frontend/src/components/ui/FollowButton.tsx
================
import { useState, useEffect } from 'react';
import { Principal } from '@dfinity/principal';
import { useSiwe } from 'ic-siwe-js/react';
import { useActor } from '../../ic/Actors';
import { BackendExtended } from '../../livepeer/types';
import { twMerge } from 'tailwind-merge';

type FollowButtonSize = 'sm' | 'md' | 'lg';

interface FollowButtonProps {
  userPrincipal: Principal;
  initialFollowState?: boolean;
  className?: string;
  onFollowStateChange?: (isFollowing: boolean) => void;
  size?: FollowButtonSize;
}

export function FollowButton({
  userPrincipal,
  initialFollowState = false,
  className = '',
  onFollowStateChange,
  size = 'md'
}: FollowButtonProps) {
  const actor = useActor();
  const { identity } = useSiwe();
  const [isFollowing, setIsFollowing] = useState(initialFollowState);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Size-based class mapping
  const sizeClasses = {
    sm: 'px-2 py-0.5 text-xs',
    md: 'px-4 py-1 text-sm',
    lg: 'px-6 py-2 text-base'
  };

  // Check initial follow status on mount
  useEffect(() => {
    const checkFollowStatus = async () => {
      if (!actor || !identity || !userPrincipal) return;
      
      try {
        const backendActor = actor as unknown as BackendExtended;
        const myPrincipal = identity.getPrincipal();
        
        // Skip if we're viewing our own profile
        if (myPrincipal.toString() === userPrincipal.toString()) return;
        
        const following = await backendActor.isFollowing(
          myPrincipal,
          userPrincipal
        );
        
        setIsFollowing(following);
        if (onFollowStateChange) {
          onFollowStateChange(following);
        }
      } catch (err) {
        console.error("Error checking follow status:", err);
        setError("Couldn't check follow status");
      }
    };
    
    checkFollowStatus();
  }, [actor, identity, userPrincipal, onFollowStateChange]);
  
  const handleFollowClick = async () => {
    if (!actor || !identity) return;
    
    // Clear any previous errors
    setError(null);
    setIsLoading(true);
    
    try {
      const backendActor = actor as unknown as BackendExtended;
      const previousState = isFollowing;
      
      // Optimistically update UI
      setIsFollowing(!isFollowing);
      if (onFollowStateChange) {
        onFollowStateChange(!isFollowing);
      }
      
      // Call appropriate API based on current follow state
      if (isFollowing) {
        const result = await backendActor.unfollowUser(userPrincipal);
        if ('Err' in result) {
          // Revert on error
          setIsFollowing(previousState);
          if (onFollowStateChange) {
            onFollowStateChange(previousState);
          }
          setError(result.Err);
        }
      } else {
        const result = await backendActor.followUser(userPrincipal);
        if ('Err' in result) {
          // Revert on error
          setIsFollowing(previousState);
          if (onFollowStateChange) {
            onFollowStateChange(previousState);
          }
          setError(result.Err);
        }
      }
    } catch (err) {
      console.error("Error updating follow status:", err);
      setError("Failed to update follow status");
      
      // Revert to previous state on error
      setIsFollowing(isFollowing);
      if (onFollowStateChange) {
        onFollowStateChange(isFollowing);
      }
    } finally {
      setIsLoading(false);
    }
  };
  
  // Don't render the button for our own profile
  if (identity && identity.getPrincipal().toString() === userPrincipal.toString()) {
    return null;
  }
  
  return (
    <div className="relative">
      <button
        onClick={handleFollowClick}
        disabled={isLoading || !identity}
        className={twMerge(
          `rounded-full transition-colors duration-200 font-medium ${sizeClasses[size]}`,
          isFollowing
            ? 'bg-blue-100 text-blue-600 dark:bg-blue-900 dark:text-blue-300 hover:bg-blue-200 dark:hover:bg-blue-800'
            : 'bg-blue-600 text-white dark:bg-blue-500 hover:bg-blue-700 dark:hover:bg-blue-600',
          isLoading && 'opacity-70 cursor-wait',
          !identity && 'opacity-50 cursor-not-allowed',
          className
        )}
        aria-label={isFollowing ? 'Unfollow' : 'Follow'}
      >
        {isLoading ? (
          <span className="flex items-center justify-center">
            <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span>{isFollowing ? 'Unfollowing...' : 'Following...'}</span>
          </span>
        ) : (
          isFollowing ? 'Following' : 'Follow'
        )}
      </button>
      
      {/* Error message */}
      {error && (
        <div className="absolute mt-1 w-full">
          <div className="bg-red-50 text-red-600 text-xs p-1 rounded border border-red-200">
            {error}
          </div>
        </div>
      )}
    </div>
  );
}

================
File: src/frontend/src/components/ui/Pill.tsx
================
import { twMerge } from "tailwind-merge";

type PillProps = {
  className?: string;
  children: React.ReactNode;
};
export default function Pill({ className, children }: PillProps) {
  className = twMerge("px-3 py-1 text-sm rounded-full bg-zinc-800", className);

  return (
    <div className={className}>
      <div className="flex items-center justify-center w-full gap-2 whitespace-nowrap">
        {children}
      </div>{" "}
    </div>
  );
}

================
File: src/frontend/src/components/video/CommentSection.tsx
================
import { useState, useEffect } from 'react';
import { useActor } from '../../ic/Actors';
import { useSiwe } from 'ic-siwe-js/react';
import { BackendExtended } from '../../livepeer/types';
import { formatDistanceToNow } from 'date-fns';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faHeart, faReply } from '@fortawesome/free-solid-svg-icons';

interface Comment {
  commenter_principal: string;
  text: string;
  timestamp: bigint;
  commenter_name?: string;
  commenter_avatar?: string;
}

interface CommentSectionProps {
  videoId: string;
  className?: string;
}

export function CommentSection({ videoId, className = '' }: CommentSectionProps) {
  const actor = useActor();
  const { identity } = useSiwe();
  const [comments, setComments] = useState<Comment[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [newCommentText, setNewCommentText] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [userProfiles, setUserProfiles] = useState<Record<string, any>>({});

  // Fetch comments
  useEffect(() => {
    if (!actor || !videoId) return;
    setIsLoading(true);
    setError(null);

    const backendActor = actor as unknown as BackendExtended;

    const fetchComments = async () => {
      try {
        const fetchedComments = await backendActor.getComments(videoId);
        
        // Sort by timestamp (newest first)
        fetchedComments.sort((a: Comment, b: Comment) => 
          Number(b.timestamp) - Number(a.timestamp)
        );
        
        setComments(fetchedComments);
        
        // Try to get user profiles for commenters
        try {
          // Use listProfiles from the base actor
          // @ts-ignore - API method exists in backend but types may not be updated
          const profilesResponse = await actor.listProfiles();
          
          // Create a map of principal -> profile for easy lookup
          const profileMap: Record<string, any> = {};
          
          if (profilesResponse && "Ok" in profilesResponse) {
            // Profiles is an array of [principal_string, UserProfile] tuples
            const profiles = profilesResponse.Ok;
            
            profiles.forEach(([principalStr, profile]: [string, any]) => {
              profileMap[principalStr] = profile;
            });
          }
          
          setUserProfiles(profileMap);
        } catch (err) {
          console.error('Error fetching user profiles:', err);
        }
        
        setIsLoading(false);
      } catch (err) {
        console.error('Error fetching comments:', err);
        setError('Failed to load comments: ' + (err instanceof Error ? err.message : String(err)));
        setIsLoading(false);
      }
    };

    fetchComments();
  }, [actor, videoId]);

  // Post a new comment
  const handleSubmitComment = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!actor || !identity || !newCommentText.trim()) return;
    
    setIsSubmitting(true);
    
    try {
      const backendActor = actor as unknown as BackendExtended;
      const newComment = await backendActor.postComment(videoId, newCommentText.trim());
      
      // Add to comments list
      setComments(prev => [newComment, ...prev]);
      setNewCommentText('');
    } catch (err) {
      console.error('Error posting comment:', err);
      setError('Failed to post comment: ' + (err instanceof Error ? err.message : String(err)));
    } finally {
      setIsSubmitting(false);
    }
  };

  // Format date from timestamp
  const formatDate = (timestamp: bigint) => {
    try {
      return formatDistanceToNow(new Date(Number(timestamp) * 1000), { addSuffix: true });
    } catch (err) {
      return 'Unknown date';
    }
  };

  // Format large numbers
  const formatNumber = (num: number) => {
    if (num >= 1_000_000) return `${(num / 1_000_000).toFixed(1)}M`;
    if (num >= 1_000) return `${(num / 1_000).toFixed(1)}K`;
    return num.toString();
  };

  // Find commenter name from profiles
  const getCommenterName = (principal: string) => {
    const profile = userProfiles[principal];
    if (profile && profile.name) {
      return profile.name;
    }
    return 'Unknown User';
  };

  // Find commenter avatar from profiles
  const getCommenterAvatar = (principal: string) => {
    const profile = userProfiles[principal];
    if (profile && profile.avatar_url) {
      return profile.avatar_url;
    }
    return null;
  };

  return (
    <div className={`bg-white dark:bg-gray-900 rounded-lg shadow ${className}`}>
      <div className="p-6 border-b dark:border-gray-800">
        <h2 className="text-xl font-semibold mb-4">
          Comments {comments.length > 0 && `(${formatNumber(comments.length)})`}
        </h2>
        
        {/* Comment Form */}
        {identity ? (
          <form onSubmit={handleSubmitComment} className="mb-6">
            <div className="flex items-start space-x-4">
              <div className="w-10 h-10 rounded-full bg-gray-300 dark:bg-gray-700 flex-shrink-0">
                {/* User avatar would go here */}
              </div>
              <div className="flex-grow">
                <textarea
                  value={newCommentText}
                  onChange={(e) => setNewCommentText(e.target.value)}
                  placeholder="Add a comment..."
                  className="w-full border dark:border-gray-700 rounded-lg p-3 bg-gray-50 dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  rows={3}
                  disabled={isSubmitting}
                ></textarea>
                <div className="flex justify-end mt-2">
                  <button
                    type="submit"
                    disabled={isSubmitting || !newCommentText.trim()}
                    className={`px-4 py-2 rounded-lg font-medium ${
                      isSubmitting || !newCommentText.trim()
                        ? 'bg-gray-300 dark:bg-gray-700 text-gray-500 dark:text-gray-400'
                        : 'bg-blue-600 text-white hover:bg-blue-700'
                    }`}
                  >
                    {isSubmitting ? 'Posting...' : 'Post'}
                  </button>
                </div>
              </div>
            </div>
          </form>
        ) : (
          <div className="py-4 px-6 bg-gray-100 dark:bg-gray-800 rounded-lg text-center mb-6">
            <p className="text-gray-700 dark:text-gray-300">Log in to comment</p>
          </div>
        )}
        
        {error && (
          <div className="bg-red-500 bg-opacity-20 text-red-100 p-4 rounded-lg mb-4">
            {error}
          </div>
        )}
        
        {/* Comments List */}
        {isLoading ? (
          <div className="space-y-6">
            {[1, 2, 3].map((i) => (
              <div key={i} className="flex space-x-4 animate-pulse">
                <div className="w-10 h-10 rounded-full bg-gray-300 dark:bg-gray-700"></div>
                <div className="flex-1 space-y-2">
                  <div className="h-4 bg-gray-300 dark:bg-gray-700 rounded w-1/4"></div>
                  <div className="h-3 bg-gray-300 dark:bg-gray-700 rounded w-3/4"></div>
                </div>
              </div>
            ))}
          </div>
        ) : comments.length === 0 ? (
          <div className="text-center py-10 text-gray-500 dark:text-gray-400">
            <p>No comments yet. Be the first to comment!</p>
          </div>
        ) : (
          <div className="space-y-6">
            {comments.map((comment, index) => (
              <div key={index} className="flex space-x-4">
                <div className="w-10 h-10 rounded-full bg-gray-300 dark:bg-gray-700 overflow-hidden flex-shrink-0">
                  {getCommenterAvatar(comment.commenter_principal) ? (
                    <img
                      src={getCommenterAvatar(comment.commenter_principal)}
                      alt={getCommenterName(comment.commenter_principal)}
                      className="w-full h-full object-cover"
                    />
                  ) : (
                    <div className="w-full h-full flex items-center justify-center text-gray-500">
                      {getCommenterName(comment.commenter_principal)[0]?.toUpperCase() || '?'}
                    </div>
                  )}
                </div>
                
                <div className="flex-1">
                  <div className="flex items-center space-x-2 mb-1">
                    <h4 className="font-medium">{getCommenterName(comment.commenter_principal)}</h4>
                    <span className="text-xs text-gray-500 dark:text-gray-400">
                      {formatDate(comment.timestamp)}
                    </span>
                  </div>
                  
                  <p className="text-gray-700 dark:text-gray-300 mb-2">{comment.text}</p>
                  
                  <div className="flex items-center space-x-4 text-sm text-gray-500 dark:text-gray-400">
                    <button className="flex items-center hover:text-red-500">
                      <FontAwesomeIcon icon={faHeart} className="mr-1" />
                      <span>Like</span>
                    </button>
                    
                    <button className="flex items-center hover:text-blue-500">
                      <FontAwesomeIcon icon={faReply} className="mr-1" />
                      <span>Reply</span>
                    </button>
                    
                    <span className="text-xs">212.8K likes</span>
                    <span className="text-xs">636 replies</span>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

================
File: src/frontend/src/components/video/index.ts
================
export * from './VideoPage';
export * from './VideoGrid';
export * from './VideoViewPage';
export * from './CommentSection';
export * from './TipModal';
export * from './TipHistory';

================
File: src/frontend/src/components/video/TipHistory.tsx
================
import { useState, useEffect } from 'react';
import { useActor } from '../../ic/Actors';
import { BackendExtended } from '../../livepeer/types';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faChevronDown, faChevronUp } from '@fortawesome/free-solid-svg-icons';
import { faEthereum } from '@fortawesome/free-brands-svg-icons';
import { formatDistanceToNow } from 'date-fns';
import { formatEther } from 'viem';

interface TipRecord {
  from_addr: string;
  to_addr: string;
  video_id: string;
  amount: bigint;
  tx_hash: string;
  timestamp: bigint;
}

interface TipHistoryProps {
  videoId: string;
  className?: string;
}

export function TipHistory({ videoId, className = '' }: TipHistoryProps) {
  const actor = useActor();
  const [tips, setTips] = useState<TipRecord[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [expanded, setExpanded] = useState(false);
  
  // Fetch tip history
  useEffect(() => {
    if (!actor || !videoId) return;
    
    const fetchTips = async () => {
      try {
        setLoading(true);
        const backendActor = actor as unknown as BackendExtended;
        const tipRecords = await backendActor.getTipsForVideo(videoId);
        
        // Sort by timestamp (newest first)
        tipRecords.sort((a, b) => Number(b.timestamp) - Number(a.timestamp));
        
        setTips(tipRecords);
        setLoading(false);
      } catch (err) {
        console.error('Error fetching tip history:', err);
        setError('Failed to load tip history');
        setLoading(false);
      }
    };
    
    fetchTips();
  }, [actor, videoId]);
  
  // Calculate total ETH tipped
  const calculateTotal = () => {
    if (!tips.length) return '0';
    
    const total = tips.reduce((sum, tip) => {
      return sum + BigInt(tip.amount);
    }, BigInt(0));
    
    return formatEther(total);
  };
  
  // Format address for display
  const formatAddress = (address: string) => {
    if (!address) return '';
    return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
  };
  
  // Format date from timestamp
  const formatDate = (timestamp: bigint) => {
    try {
      return formatDistanceToNow(new Date(Number(timestamp) * 1000), { addSuffix: true });
    } catch (err) {
      return 'Unknown date';
    }
  };
  
  // If there are no tips, don't show the component
  if (tips.length === 0 && !loading) return null;
  
  return (
    <div className={`bg-white dark:bg-zinc-900 rounded-lg shadow ${className}`}>
      {/* Header - always visible */}
      <div 
        className="p-4 border-b dark:border-zinc-800 flex items-center justify-between cursor-pointer"
        onClick={() => setExpanded(!expanded)}
      >
        <div>
          <h3 className="text-lg font-medium text-gray-900 dark:text-white flex items-center">
            <FontAwesomeIcon icon={faEthereum} className="text-blue-500 mr-2" />
            Tip History
          </h3>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            {loading ? 'Loading...' : `${tips.length} tip${tips.length !== 1 ? 's' : ''} • Total: ${calculateTotal()} ETH`}
          </p>
        </div>
        <FontAwesomeIcon 
          icon={expanded ? faChevronUp : faChevronDown} 
          className="text-gray-500 dark:text-gray-400"
        />
      </div>
      
      {/* Expanded content */}
      {expanded && (
        <div className="p-4">
          {loading ? (
            <div className="py-4 flex justify-center">
              <div className="animate-spin h-6 w-6 text-blue-500">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              </div>
            </div>
          ) : error ? (
            <div className="text-red-500 dark:text-red-400 text-center py-4">
              {error}
            </div>
          ) : (
            <div className="space-y-4">
              {tips.slice(0, 5).map((tip, index) => (
                <div key={index} className="flex items-center justify-between py-2 border-b dark:border-zinc-800 last:border-0">
                  <div>
                    <div className="flex items-center">
                      <FontAwesomeIcon icon={faEthereum} className="text-blue-500 mr-2" />
                      <span className="font-medium">{formatEther(tip.amount)} ETH</span>
                    </div>
                    <div className="text-sm text-gray-600 dark:text-gray-400">
                      From: {formatAddress(tip.from_addr)}
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="text-sm text-gray-600 dark:text-gray-400">
                      {formatDate(tip.timestamp)}
                    </div>
                    <a
                      href={`https://etherscan.io/tx/${tip.tx_hash}`}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-xs text-blue-600 hover:text-blue-700 dark:text-blue-400"
                      onClick={(e) => e.stopPropagation()}
                    >
                      View transaction
                    </a>
                  </div>
                </div>
              ))}
              
              {tips.length > 5 && (
                <div className="text-center">
                  <a
                    href="#"
                    className="text-sm text-blue-600 hover:text-blue-700 dark:text-blue-400"
                    onClick={(e) => {
                      e.preventDefault();
                      // This could open a full history modal in the future
                    }}
                  >
                    View all {tips.length} tips
                  </a>
                </div>
              )}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

================
File: src/frontend/src/components/video/TipModal.tsx
================
import { useState, useEffect } from 'react';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faXmark, faCheck, faExclamationTriangle } from '@fortawesome/free-solid-svg-icons';
import { faEthereum } from '@fortawesome/free-brands-svg-icons';
import { useAccount, useBalance, useSendTransaction } from 'wagmi';
import { parseEther } from 'viem';
import { twMerge } from 'tailwind-merge';
import { FundWallet } from '../../cdp/FundWallet';

interface TipModalProps {
  isOpen: boolean;
  onClose: () => void;
  recipientAddress: string;
  videoId?: string; // Made optional since it's not used in this component
  onTipComplete: (amount: string, txHash: string) => Promise<void>;
  className?: string;
}

type TipStatus = 'idle' | 'preparing' | 'waiting' | 'success' | 'error';

const PREDEFINED_AMOUNTS = [
  { label: '0.001 ETH', value: '0.001' },
  { label: '0.01 ETH', value: '0.01' },
  { label: '0.05 ETH', value: '0.05' },
  { label: '0.1 ETH', value: '0.1' },
];

export function TipModal({ 
  isOpen, 
  onClose, 
  recipientAddress, 
  onTipComplete,
  className = '' 
}: TipModalProps) {
  const [selectedAmount, setSelectedAmount] = useState<string>('0.01');
  const [customAmount, setCustomAmount] = useState<string>('');
  const [tipStatus, setTipStatus] = useState<TipStatus>('idle');
  const [txHash, setTxHash] = useState<string>('');
  const [errorMessage, setErrorMessage] = useState<string>('');
  
  const { address } = useAccount();
  const { data: balance } = useBalance({
    address: address,
  });
  
  const { sendTransaction, isPending, isSuccess, isError, error } = useSendTransaction();
  
  // Handle transaction state changes
  useEffect(() => {
    if (isPending) {
      setTipStatus('waiting');
    } else if (isSuccess) {
      setTipStatus('success');
    } else if (isError) {
      setTipStatus('error');
      setErrorMessage(error?.message || 'Transaction failed');
    }
  }, [isPending, isSuccess, isError, error]);
  
  // Reset state when modal opens
  useEffect(() => {
    if (isOpen) {
      setSelectedAmount('0.01');
      setCustomAmount('');
      setTipStatus('idle');
      setTxHash('');
      setErrorMessage('');
    }
  }, [isOpen]);
  
  const handleAmountSelect = (amount: string) => {
    setSelectedAmount(amount);
    setCustomAmount('');
  };
  
  const handleCustomAmountChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    // Only allow valid decimal numbers
    if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {
      setCustomAmount(value);
      setSelectedAmount('');
    }
  };
  
  const getEffectiveAmount = (): string => {
    return customAmount || selectedAmount;
  };
  
  const isAmountValid = (): boolean => {
    const amount = parseFloat(getEffectiveAmount());
    return amount > 0 && amount <= parseFloat(balance?.formatted || '0');
  };
  
  const handleSendTip = async () => {
    try {
      setTipStatus('preparing');
      
      // Get the amount to send
      const amount = getEffectiveAmount();
      
      // Validate amount
      if (!isAmountValid()) {
        setTipStatus('error');
        setErrorMessage('Invalid amount or insufficient balance');
        return;
      }
      
      // Parse amount to Wei
      const valueInWei = parseEther(amount);
      
      // Send transaction
      sendTransaction({
        to: recipientAddress as `0x${string}`,
        value: valueInWei,
      });
      
      // Note: The transaction hash will be set in a separate effect when the transaction succeeds
    } catch (err) {
      console.error('Error sending tip:', err);
      setTipStatus('error');
      setErrorMessage(err instanceof Error ? err.message : 'Error sending tip');
    }
  };
  
  const handleConfirmTip = async () => {
    try {
      // This would be called after transaction is confirmed
      await onTipComplete(getEffectiveAmount(), txHash);
      // Don't close the modal - let user see success state
    } catch (err) {
      console.error('Error recording tip on backend:', err);
      setErrorMessage(err instanceof Error ? 
        err.message : 'Transaction was successful, but failed to record on backend'
      );
    }
  };
  
  // Determine if we should show the modal
  if (!isOpen) return null;
  
  return (
    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
      <div className={twMerge("bg-white dark:bg-zinc-900 rounded-xl w-full max-w-md p-6 relative", className)}>
        {/* Close button */}
        <button 
          onClick={onClose}
          className="absolute right-4 top-4 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
        >
          <FontAwesomeIcon icon={faXmark} className="text-xl" />
        </button>
        
        <div className="mb-6">
          <h2 className="text-2xl font-bold text-gray-900 dark:text-white mb-2">
            Tip Creator
          </h2>
          <p className="text-gray-600 dark:text-gray-400">
            Send ETH directly to the video creator
          </p>
        </div>
        
        {tipStatus === 'idle' || tipStatus === 'preparing' ? (
          <>
            {/* Recipient info */}
            <div className="mb-6 p-3 bg-gray-100 dark:bg-zinc-800 rounded-lg">
              <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">
                Sending to:
              </p>
              <p className="text-gray-900 dark:text-white font-mono text-sm break-all">
                {recipientAddress}
              </p>
            </div>
            
            {/* Predefined amounts */}
            <div className="mb-6">
              <p className="text-sm text-gray-700 dark:text-gray-300 mb-2">
                Select amount:
              </p>
              <div className="grid grid-cols-2 gap-2">
                {PREDEFINED_AMOUNTS.map((option) => (
                  <button
                    key={option.value}
                    onClick={() => handleAmountSelect(option.value)}
                    className={`py-2 px-4 rounded-lg transition-colors ${
                      selectedAmount === option.value
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-200 dark:bg-zinc-800 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-zinc-700'
                    }`}
                  >
                    {option.label}
                  </button>
                ))}
              </div>
            </div>
            
            {/* Custom amount */}
            <div className="mb-6">
              <p className="text-sm text-gray-700 dark:text-gray-300 mb-2">
                Or enter custom amount:
              </p>
              <div className="relative">
                <input
                  type="text"
                  value={customAmount}
                  onChange={handleCustomAmountChange}
                  placeholder="0.00"
                  className="w-full py-2 px-4 pl-9 border dark:border-zinc-700 rounded-lg bg-white dark:bg-zinc-800 focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                <FontAwesomeIcon
                  icon={faEthereum}
                  className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500"
                />
              </div>
              
              <div className="mt-2 flex justify-between text-sm">
                <span className="text-gray-600 dark:text-gray-400">
                  Your balance: {balance?.formatted?.substring(0, 8) || '0'} ETH
                </span>
                {parseFloat(getEffectiveAmount()) > parseFloat(balance?.formatted || '0') && (
                  <span className="text-red-500">
                    Insufficient balance
                  </span>
                )}
              </div>
            </div>
            
            {/* Need funds section */}
            {parseFloat(balance?.formatted || '0') < 0.01 && (
              <div className="mb-6">
                <p className="text-sm text-gray-600 dark:text-gray-400 mb-2">
                  Need to add funds to your wallet?
                </p>
                <FundWallet className="mb-2" />
              </div>
            )}
            
            {/* Send button */}
            <button
              onClick={handleSendTip}
              disabled={!isAmountValid() || tipStatus === 'preparing'}
              className={`w-full py-3 px-4 rounded-lg font-medium flex items-center justify-center ${
                !isAmountValid() || tipStatus === 'preparing'
                  ? 'bg-gray-300 dark:bg-zinc-700 text-gray-500 dark:text-gray-400 cursor-not-allowed'
                  : 'bg-blue-600 text-white hover:bg-blue-700'
              }`}
            >
              {tipStatus === 'preparing' ? (
                <>
                  <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  Preparing...
                </>
              ) : (
                <>
                  <FontAwesomeIcon icon={faEthereum} className="mr-2" />
                  Send {getEffectiveAmount()} ETH
                </>
              )}
            </button>
          </>
        ) : tipStatus === 'waiting' ? (
          <div className="text-center py-8">
            <div className="animate-spin mx-auto mb-4 h-12 w-12 text-blue-500">
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
            </div>
            <h3 className="text-xl font-medium text-gray-900 dark:text-white mb-2">
              Transaction in progress
            </h3>
            <p className="text-gray-600 dark:text-gray-400 mb-4">
              Please confirm the transaction in your wallet...
            </p>
          </div>
        ) : tipStatus === 'success' ? (
          <div className="text-center py-8">
            <div className="flex items-center justify-center mx-auto mb-4 h-16 w-16 rounded-full bg-green-100 dark:bg-green-900">
              <FontAwesomeIcon icon={faCheck} className="text-2xl text-green-600 dark:text-green-400" />
            </div>
            <h3 className="text-xl font-medium text-gray-900 dark:text-white mb-2">
              Tip sent successfully!
            </h3>
            <p className="text-gray-600 dark:text-gray-400 mb-6">
              Thank you for supporting the creator
            </p>
            {/* Transaction hash display */}
            {txHash && (
              <div className="mb-6 p-3 bg-gray-100 dark:bg-zinc-800 rounded-lg">
                <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">
                  Transaction Hash:
                </p>
                <p className="text-gray-900 dark:text-white font-mono text-sm break-all">
                  {txHash.substring(0, 10)}...{txHash.substring(txHash.length - 10)}
                </p>
                <a
                  href={`https://etherscan.io/tx/${txHash}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-sm text-blue-600 hover:text-blue-700 dark:text-blue-400"
                >
                  View on Etherscan
                </a>
              </div>
            )}
            <div className="flex space-x-3">
              <button
                onClick={handleConfirmTip}
                className="flex-1 py-2 px-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
              >
                Confirm Tip
              </button>
              <button
                onClick={onClose}
                className="flex-1 py-2 px-4 border border-gray-300 dark:border-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-100 dark:hover:bg-zinc-800"
              >
                Close
              </button>
            </div>
          </div>
        ) : tipStatus === 'error' ? (
          <div className="text-center py-8">
            <div className="flex items-center justify-center mx-auto mb-4 h-16 w-16 rounded-full bg-red-100 dark:bg-red-900">
              <FontAwesomeIcon icon={faExclamationTriangle} className="text-2xl text-red-600 dark:text-red-400" />
            </div>
            <h3 className="text-xl font-medium text-gray-900 dark:text-white mb-2">
              Transaction Failed
            </h3>
            <p className="text-red-600 dark:text-red-400 mb-6">
              {errorMessage || 'There was an error processing your transaction.'}
            </p>
            <div className="flex space-x-3">
              <button
                onClick={() => setTipStatus('idle')}
                className="flex-1 py-2 px-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
              >
                Try Again
              </button>
              <button
                onClick={onClose}
                className="flex-1 py-2 px-4 border border-gray-300 dark:border-gray-700 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-100 dark:hover:bg-zinc-800"
              >
                Cancel
              </button>
            </div>
          </div>
        ) : null}
      </div>
    </div>
  );
}

================
File: src/frontend/src/components/video/VideoGrid.tsx
================
import { useState, useEffect } from 'react';
import { useActor } from '../../ic/Actors';
// BackendExtended no longer needed with our proxy
import { twMerge } from 'tailwind-merge';
import { formatDistanceToNow } from 'date-fns';

interface VideoGridProps {
  tag?: string;
  className?: string;
  onVideoSelect?: (videoId: string) => void;
}

export function VideoGrid({ tag, className = '', onVideoSelect }: VideoGridProps) {
  const actor = useActor();
  const [videos, setVideos] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  // Removed unused state

  // Load videos based on tag or all videos
  useEffect(() => {
    setLoading(true);
    setError(null);
    
    const fetchVideos = async () => {
      if (!actor) return;
      
      try {
        let videoList: any[];
        // Actor is now handled through our proxy
        
        if (tag) {
          try {
            console.log('Searching videos by tag:', tag);
            // @ts-ignore - Our proxy handles this correctly
            videoList = await actor.list_videos_by_tag(tag.toLowerCase());
            console.log(`Found ${videoList.length} videos with tag: ${tag}`);
          } catch (err) {
            console.error(`Error searching for videos with tag ${tag}:`, err);
            videoList = [];
          }
        } else {
          // Try using the properly fixed actor methods
          try {
            console.log('Getting all videos in VideoGrid');
            // Need to access the nested actor directly
            // @ts-ignore
            videoList = await actor.actor.list_all_videos();
            console.log("Successfully loaded videos:", videoList);
          } catch (err) {
            console.error("Error loading videos:", err);
            videoList = [];
          }
          console.log("Loaded videos for grid:", videoList);
        }
        
        // Sort videos by timestamp (newest first)
        videoList.sort((a, b) => Number(b.timestamp) - Number(a.timestamp));
        
        setVideos(videoList);
      } catch (err) {
        console.error('Error fetching videos:', err);
        setError('Failed to load videos: ' + (err instanceof Error ? err.message : String(err)));
        setVideos([]);
      } finally {
        setLoading(false);
      }
    };
    
    fetchVideos();
  }, [actor, tag]);

  // Format view counts
  const formatViewCount = (count: number) => {
    if (count >= 1_000_000) return `${(count / 1_000_000).toFixed(1)}M`;
    if (count >= 1_000) return `${(count / 1_000).toFixed(1)}K`;
    return count.toString();
  };

  // Calculate time ago from timestamp
  const getTimeAgo = (timestamp: bigint) => {
    try {
      return formatDistanceToNow(new Date(Number(timestamp) * 1000), { addSuffix: true });
    } catch (err) {
      return 'Unknown time';
    }
  };

  // Get video thumbnail from storage_ref
  const getVideoThumbnail = (video: any) => {
    if (!video.storage_ref) return '/default-thumbnail.jpg';
    
    // If LivePeer, we could generate thumbnail URL based on playback ID
    // This is a placeholder - you'd need to implement actual thumbnail generation
    if (video.storage_ref.startsWith('livepeer:')) {
      const playbackId = video.storage_ref.substring(9);
      return `https://livepeercdn.com/asset/${playbackId}/thumbnail.jpg`;
    }
    
    return '/default-thumbnail.jpg';
  };

  return (
    <div className={twMerge('container mx-auto px-4 py-6', className)}>
      {/* Search and category tabs removed since they're in the layout */}
      
      {/* Video Grid */}
      {error ? (
        <div className="bg-red-500 bg-opacity-20 text-red-100 p-6 rounded-lg mb-4">
          <h3 className="text-lg font-medium mb-2">Error Loading Videos</h3>
          <p>{error}</p>
        </div>
      ) : loading ? (
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
          {Array.from({ length: 8 }).map((_, i) => (
            <div key={i} className="animate-pulse">
              <div className="aspect-[9/16] bg-gray-300 dark:bg-gray-700 rounded-lg mb-2"></div>
              <div className="h-4 bg-gray-300 dark:bg-gray-700 rounded w-3/4 mb-1"></div>
              <div className="h-3 bg-gray-300 dark:bg-gray-700 rounded w-1/2"></div>
            </div>
          ))}
        </div>
      ) : videos.length === 0 ? (
        <div className="text-center py-16 text-gray-500 dark:text-gray-400">
          <h3 className="text-xl font-medium mb-2">No Videos Found</h3>
          <p>
            {tag
              ? `No videos found with the category "${tag}"`
              : 'No videos have been uploaded yet'
            }
          </p>
        </div>
      ) : (
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
          {videos.map((video) => (
            <div 
              key={video.video_id}
              className="cursor-pointer hover:opacity-90 transition-opacity"
              onClick={() => onVideoSelect && onVideoSelect(video.video_id)}
            >
              {/* Video Thumbnail */}
              <div className="aspect-[9/16] bg-gray-200 dark:bg-gray-800 rounded-lg overflow-hidden mb-2">
                <img 
                  src={getVideoThumbnail(video)} 
                  alt={video.title}
                  className="w-full h-full object-cover"
                />
              </div>
              
              {/* Video Info */}
              <div className="flex items-start space-x-2">
                {/* Creator Avatar - could be fetched in the future */}
                <div className="w-8 h-8 rounded-full bg-gray-300 dark:bg-gray-700 flex-shrink-0 mt-1"></div>
                
                <div>
                  <h3 className="font-medium text-gray-900 dark:text-gray-100 line-clamp-2 mb-1">
                    {video.title}
                  </h3>
                  <p className="text-sm text-gray-600 dark:text-gray-400">
                    @user_{video.uploader_principal.toString().substring(0, 8)}
                  </p>
                  <div className="flex items-center space-x-1 text-xs text-gray-500 dark:text-gray-400">
                    <span>{formatViewCount(Math.floor(Math.random() * 20_000_000))} views</span>
                    <span>•</span>
                    <span>{getTimeAgo(video.timestamp)}</span>
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

================
File: src/frontend/src/components/video/VideoPage.tsx
================
import { useState } from 'react';
import { VideoGrid } from './VideoGrid';
import { VideoViewPage } from './VideoViewPage';
import { twMerge } from 'tailwind-merge';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faArrowLeft, faUpload } from '@fortawesome/free-solid-svg-icons';
import { useSiwe } from 'ic-siwe-js/react';

interface VideoPageProps {
  className?: string;
}

export function VideoPage({ className = '' }: VideoPageProps) {
  const [selectedVideoId, setSelectedVideoId] = useState<string | null>(null);
  const [viewMode, setViewMode] = useState<'grid' | 'view'>('grid');
  const { identity } = useSiwe();

  // Handle video selection from grid
  const handleVideoSelect = (videoId: string) => {
    setSelectedVideoId(videoId);
    setViewMode('view');
  };

  // Handle back button click
  const handleBackClick = () => {
    setViewMode('grid');
    setSelectedVideoId(null);
  };

  // Render upload button (could be moved to a separate component)
  const renderUploadButton = () => {
    if (!identity) return null;

    return (
      <button
        className="fixed bottom-6 right-6 z-10 bg-blue-600 text-white p-4 rounded-full shadow-lg hover:bg-blue-700 transition-colors"
        title="Upload new video"
        onClick={() => {
          // Implement upload functionality or navigation
          console.log('Upload video clicked');
        }}
      >
        <FontAwesomeIcon icon={faUpload} className="text-xl" />
      </button>
    );
  };

  return (
    <div className={twMerge('min-h-screen bg-white dark:bg-gray-900', className)}>
      {viewMode === 'view' && selectedVideoId ? (
        <>
          <div className="sticky top-0 left-0 z-20 p-4 bg-white dark:bg-gray-900">
            <button
              onClick={handleBackClick}
              className="flex items-center text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300"
            >
              <FontAwesomeIcon icon={faArrowLeft} className="mr-2" />
              <span>Back to videos</span>
            </button>
          </div>
          <VideoViewPage videoId={selectedVideoId} />
        </>
      ) : (
        <>
          <VideoGrid onVideoSelect={handleVideoSelect} />
          {renderUploadButton()}
        </>
      )}
    </div>
  );
}

================
File: src/frontend/src/components/video/VideoViewPage.tsx
================
import { useState, useEffect } from 'react';
import { useActor } from '../../ic/Actors';
import { useSiwe } from 'ic-siwe-js/react';
import { VideoPlayer } from '../../livepeer/VideoPlayer';
import { BackendExtended, UserProfile } from '../../livepeer/types';
import { twMerge } from 'tailwind-merge';
import { formatDistanceToNow } from 'date-fns';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faHeart, faComment, faShare, faCoins, faUser } from '@fortawesome/free-solid-svg-icons';
import { CommentSection } from './CommentSection';
import { TipModal } from './TipModal';
import { TipHistory } from './TipHistory';
import { useAccount } from 'wagmi';
import { FollowButton } from '../ui/FollowButton';
import { FollowSection } from '../profile/FollowSection';
import { Principal } from '@dfinity/principal';
import Dialog from '../ui/Dialog';

interface VideoViewPageProps {
  videoId: string;
  className?: string;
}

export function VideoViewPage({ videoId, className = '' }: VideoViewPageProps) {
  const actor = useActor();
  const { identity } = useSiwe();
  const { } = useAccount();
  const [videoMetadata, setVideoMetadata] = useState<any>(null);
  const [videoAnalytics, setVideoAnalytics] = useState<any>(null);
  const [uploader, setUploader] = useState<UserProfile | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isFollowing, setIsFollowing] = useState(false);
  const [isTipModalOpen, setIsTipModalOpen] = useState(false);
  const [followersCount, setFollowersCount] = useState(0);
  const [isFollowersModalOpen, setIsFollowersModalOpen] = useState(false);

  // Fetch video data and check follow status
  useEffect(() => {
    if (!actor || !videoId) return;
    setIsLoading(true);
    setError(null);

    const backendActor = actor as unknown as BackendExtended;

    // Fetch video metadata
    const fetchVideoData = async () => {
      try {
        const metadata = await backendActor.getVideoMetadata(videoId);
        setVideoMetadata(metadata);

        // Get video analytics
        try {
          const analytics = await backendActor.getVideoAnalytics(videoId);
          setVideoAnalytics(analytics);
        } catch (err) {
          console.error('Error fetching video analytics:', err);
        }

        // Try to get uploader profile
        try {
          // Get profiles from actor directly
          // @ts-ignore - API method exists in backend but types may not be updated
          const profilesResponse = await actor.listProfiles();
          if (profilesResponse && "Ok" in profilesResponse) {
            // Profiles is an array of [principal_string, UserProfile] tuples
            const profiles = profilesResponse.Ok;
            const uploaderProfile = profiles.find(
              ([_, profile]: [string, UserProfile]) => 
                profile.principal?.toString() === metadata.uploader_principal.toString()
            );
            
            if (uploaderProfile) {
              setUploader(uploaderProfile[1]);
              
              // Check if the current user is following the uploader and get followers count
              try {
                const uploaderPrincipal = Principal.fromText(metadata.uploader_principal.toString());
                
                // Get followers count
                const followers = await backendActor.getFollowers(uploaderPrincipal);
                setFollowersCount(followers.length);
                
                // Check follow status if user is authenticated
                if (identity) {
                  const isFollowingResult = await backendActor.isFollowing(
                    identity.getPrincipal(),
                    uploaderPrincipal
                  );
                  setIsFollowing(isFollowingResult);
                }
              } catch (err) {
                console.error('Error checking follow status:', err);
              }
            }
          }
        } catch (err) {
          console.error('Error fetching uploader profile:', err);
        }

        setIsLoading(false);
      } catch (err) {
        console.error('Error fetching video metadata:', err);
        setError('Failed to load video: ' + (err instanceof Error ? err.message : String(err)));
        setIsLoading(false);
      }
    };

    fetchVideoData();
  }, [actor, videoId, identity]);

  // Update state when follow status changes
  const handleFollowStateChange = (isFollowingState: boolean) => {
    setIsFollowing(isFollowingState);
  };

  const handleShareClick = () => {
    // Implement share functionality
    const shareUrl = window.location.href;
    navigator.clipboard.writeText(shareUrl);
    // Show a toast notification
  };

  // Share functionality implemented directly in handleShareClick

  // Format date from timestamp
  const formatDate = (timestamp: bigint) => {
    try {
      return formatDistanceToNow(new Date(Number(timestamp) * 1000), { addSuffix: true });
    } catch (err) {
      return 'Unknown date';
    }
  };

  // Format large numbers (e.g., 1.2M instead of 1,200,000)
  const formatNumber = (num: number | bigint) => {
    const n = typeof num === 'bigint' ? Number(num) : num;
    if (n >= 1_000_000) return `${(n / 1_000_000).toFixed(1)}M`;
    if (n >= 1_000) return `${(n / 1_000).toFixed(1)}K`;
    return n.toString();
  };

  return (
    <div className={twMerge('flex flex-col lg:flex-row max-w-screen-2xl mx-auto px-4 py-6', className)}>
      {/* Top Search removed since it's already in the layout */}

      {/* Main Content Area */}
      <div className="flex flex-col lg:flex-row gap-6 w-full">
        {/* Left: Video Player */}
        <div className="w-full lg:w-8/12">
          {error ? (
            <div className="bg-red-500 bg-opacity-20 text-red-100 p-6 rounded-lg mb-4">
              <h3 className="text-lg font-medium mb-2">Error Loading Video</h3>
              <p>{error}</p>
            </div>
          ) : isLoading || !videoMetadata ? (
            <div className="aspect-video bg-gray-200 dark:bg-gray-800 rounded-lg animate-pulse"></div>
          ) : (
            <div className="rounded-lg overflow-hidden">
              <VideoPlayer
                videoId={videoId}
                className="w-full"
                autoPlay={true}
                loop={false}
              />
            </div>
          )}
        </div>

        {/* Right: Post Details & Engagement */}
        <div className="w-full lg:w-4/12 space-y-6">
          {isLoading || !videoMetadata ? (
            <div className="space-y-4 animate-pulse">
              <div className="h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4"></div>
              <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2"></div>
              <div className="h-20 bg-gray-200 dark:bg-gray-700 rounded"></div>
            </div>
          ) : (
            <>
              {/* Post Header */}
              <div className="flex items-center justify-between">
                <div className="flex items-center">
                  <div className="w-10 h-10 rounded-full bg-gray-300 dark:bg-gray-700 overflow-hidden mr-3">
                    {uploader?.avatar_url ? (
                      <img
                        src={uploader.avatar_url}
                        alt={uploader.name}
                        className="w-full h-full object-cover"
                      />
                    ) : (
                      <div className="w-full h-full flex items-center justify-center text-gray-500">
                        {uploader?.name?.[0]?.toUpperCase() || '?'}
                      </div>
                    )}
                  </div>
                  <div>
                    <div className="font-medium">@{uploader?.name || 'unknown'}</div>
                    <div className="text-sm flex gap-2">
                      <span className="text-gray-500">
                        {videoMetadata.timestamp ? formatDate(videoMetadata.timestamp) : 'Unknown date'}
                      </span>
                      <button 
                        onClick={() => setIsFollowersModalOpen(true)}
                        className="font-medium text-blue-600 dark:text-blue-400 hover:underline flex items-center"
                      >
                        <FontAwesomeIcon icon={faUser} className="mr-1 text-xs" />
                        {followersCount} {followersCount === 1 ? 'follower' : 'followers'}
                      </button>
                    </div>
                  </div>
                </div>
                {videoMetadata && videoMetadata.uploader_principal && (
                  <FollowButton 
                    userPrincipal={Principal.fromText(videoMetadata.uploader_principal.toString())}
                    initialFollowState={isFollowing}
                    onFollowStateChange={handleFollowStateChange}
                  />
                )}
              </div>

              {/* Post Caption */}
              <div className="space-y-2">
                <h1 className="text-xl font-semibold">{videoMetadata.title}</h1>
                <p className="text-gray-700 dark:text-gray-300">
                  {videoMetadata.description || 'No description'}
                </p>
                <div className="flex flex-wrap gap-2">
                  {videoMetadata.tags?.map((tag: string, index: number) => (
                    <span
                      key={index}
                      className="text-blue-600 dark:text-blue-400 text-sm"
                    >
                      #{tag}
                    </span>
                  ))}
                </div>
              </div>

              {/* Engagement Stats */}
              <div className="flex justify-between py-4 border-t border-b dark:border-gray-700">
                <div className="text-center">
                  <div className="text-lg font-medium">
                    {videoAnalytics ? formatNumber(videoAnalytics.total_likes) : '0'}
                  </div>
                  <div className="text-xs text-gray-500">Likes</div>
                </div>
                <div className="text-center">
                  <div className="text-lg font-medium">
                    {videoAnalytics ? formatNumber(videoAnalytics.total_views) : '0'}
                  </div>
                  <div className="text-xs text-gray-500">Views</div>
                </div>
                <div className="text-center">
                  <div className="text-lg font-medium">
                    {videoAnalytics ? formatNumber(videoAnalytics.total_completions) : '0'}
                  </div>
                  <div className="text-xs text-gray-500">Completions</div>
                </div>
                <div className="text-center">
                  <div className="text-lg font-medium">
                    {/* Placeholder for shares or saves */}
                    0
                  </div>
                  <div className="text-xs text-gray-500">Shares</div>
                </div>
              </div>

              {/* Post Actions */}
              <div className="flex justify-between">
                <button className="flex items-center text-gray-700 dark:text-gray-300 hover:text-red-500 dark:hover:text-red-400">
                  <FontAwesomeIcon icon={faHeart} className="mr-2" />
                  <span>Like</span>
                </button>
                <button className="flex items-center text-gray-700 dark:text-gray-300 hover:text-blue-500 dark:hover:text-blue-400">
                  <FontAwesomeIcon icon={faComment} className="mr-2" />
                  <span>Comment</span>
                </button>
                <button
                  onClick={() => setIsTipModalOpen(true)}
                  disabled={!identity}
                  className={`flex items-center ${
                    identity 
                      ? 'text-gray-700 dark:text-gray-300 hover:text-yellow-500 dark:hover:text-yellow-400' 
                      : 'text-gray-500 dark:text-gray-600 cursor-not-allowed'
                  }`}
                >
                  <FontAwesomeIcon icon={faCoins} className="mr-2" />
                  <span>Tip</span>
                </button>
                <button
                  onClick={handleShareClick}
                  className="flex items-center text-gray-700 dark:text-gray-300 hover:text-green-500 dark:hover:text-green-400"
                >
                  <FontAwesomeIcon icon={faShare} className="mr-2" />
                  <span>Share</span>
                </button>
              </div>
            </>
          )}
        </div>
      </div>

      {/* Comment Section and Tip History */}
      <div className="mt-8 w-full space-y-6">
        {!isLoading && videoMetadata && uploader && (
          <>
            {/* Tip History Component */}
            <TipHistory videoId={videoId} />
            
            {/* Comment Section */}
            <CommentSection videoId={videoId} />
            
            {/* Tip Modal */}
            <TipModal
              isOpen={isTipModalOpen}
              onClose={() => setIsTipModalOpen(false)}
              recipientAddress={uploader.evm_address}
              videoId={videoId}
              onTipComplete={async (amount, txHash) => {
                try {
                  // Record the tip in the backend
                  const backendActor = actor as unknown as BackendExtended;
                  // Convert amount to bigint with 18 decimals (ETH)
                  const amountInWei = BigInt(parseFloat(amount) * 10**18);
                  
                  await backendActor.recordTip(videoId, amountInWei, txHash);
                  
                  // Close modal after successful recording
                  setIsTipModalOpen(false);
                  
                  // You could add a toast notification here
                  
                } catch (err) {
                  console.error('Failed to record tip:', err);
                  throw err;
                }
              }}
            />
            
            {/* Followers Modal */}
            {videoMetadata && videoMetadata.uploader_principal && (
              <Dialog
                isOpen={isFollowersModalOpen}
                setIsOpen={setIsFollowersModalOpen}
              >
                <FollowSection 
                  userPrincipal={Principal.fromText(videoMetadata.uploader_principal.toString())}
                  className="max-h-[70vh]"
                  onProfileClick={(profile) => {
                    // Here you could navigate to profile page
                    console.log('Navigate to profile:', profile);
                    // Close modal after clicking a profile
                    setIsFollowersModalOpen(false);
                  }}
                />
              </Dialog>
            )}
          </>
        )}
      </div>
    </div>
  );
}

================
File: src/frontend/src/components/AccountDialog.tsx
================
import { useAccount, useDisconnect, useEnsName } from "wagmi";

import Button from "./ui/Button";
import Dialog from "./ui/Dialog";
import { Dialog as HeadlessDialog } from "@headlessui/react";

export function AccountDialog({
  isOpen,
  setIsOpen,
}: {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
}) {
  const { address } = useAccount();
  const { disconnect } = useDisconnect();

  const { data: ensName } = useEnsName({ address, chainId: 1 });

  return (
    <Dialog className="w-80" isOpen={isOpen} setIsOpen={setIsOpen}>
      <img
        alt="Internet Computer"
        className="inline-block w-12 h-12"
        src="/ethereum.svg"
      />{" "}
      <HeadlessDialog.Title className="flex justify-between">
        Ethereum Address
      </HeadlessDialog.Title>
      <div className="px-4 py-2 text-xs rounded-lg text-zinc-400 bg-zinc-900/50">
        <code className="md:whitespace-nowrap">{ensName ?? address}</code>
      </div>
      <div className="flex justify-center w-full gap-5">
        <Button onClick={() => setIsOpen(false)} variant="outline">
          Close
        </Button>
        <Button
          onClick={() => {
            setIsOpen(false);
            disconnect();
          }}
        >
          Disconnect
        </Button>
      </div>
    </Dialog>
  );
}

================
File: src/frontend/src/components/AddressPill.tsx
================
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import Pill from "./ui/Pill";
import { faEthereum } from "@fortawesome/free-brands-svg-icons";
import { shortenEthAddress } from "../eth/utils/shortenEthAddress";

export default function AddressPill({
  address,
  className,
}: {
  address?: string;
  className?: string;
}) {
  if (!address) return null;
  return (
    <Pill className={className}>
      <FontAwesomeIcon className="w-3 h-3" icon={faEthereum} />
      {shortenEthAddress(address)}
    </Pill>
  );
}

================
File: src/frontend/src/components/ConnectDialog.tsx
================
import { Connector, useAccount, useConnect } from "wagmi";

import Button from "./ui/Button";
import Dialog from "./ui/Dialog";
import { Dialog as HeadlessDialog } from "@headlessui/react";
import { faCircleNotch } from "@fortawesome/free-solid-svg-icons";
import { useEffect } from "react";

export default function ConnectDialog({
  isOpen,
  setIsOpen,
}: {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
}) {
  const { connect, connectors, error, isPending, variables, reset } =
    useConnect();
  const { isConnected } = useAccount();

  useEffect(() => {
    if (isOpen) reset();
  }, [isOpen, reset]);

  const icon = (connector: Connector) => {
    if (
      isPending &&
      variables &&
      "id" in variables.connector &&
      connector.id === variables.connector.id
    ) {
      return faCircleNotch;
    }
    return undefined;
  };

  const iconSource = (connector: Connector) => {
    // WalletConnect does not provide an icon, so we provide a custom one.
    if (connector.id === "walletConnect") {
      return "/walletconnect.svg";
    }
    return connector.icon;
  };

  return (
    <Dialog
      className="relative z-50 w-80"
      isOpen={isOpen}
      setIsOpen={setIsOpen}
    >
      <HeadlessDialog.Title> Connect Wallet</HeadlessDialog.Title>

      {connectors.map((connector) => (
        <Button
          className="justify-between w-52"
          disabled={isConnected || isPending}
          icon={icon(connector)}
          key={connector.id}
          onClick={() => connect({ connector })}
          spin
          variant="outline"
        >
          {connector.name}
          <img className="w-4 h-4" src={iconSource(connector)} />
        </Button>
      ))}
      {error && (
        <div className="p-2 text-center text-white bg-red-500">
          {error.message}
        </div>
      )}
    </Dialog>
  );
}

================
File: src/frontend/src/components/GitHubIcon.tsx
================
import { faGithub } from "@fortawesome/free-brands-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";

export default function GitHubIcon() {
  return (
    <div className="flex flex-col items-center w-full max-w-2xl gap-5 text-center">
      <a
        href="https://github.com/kristoferlund/ic-siwe-react-demo-rust"
        rel="noreferrer"
        target="_blank"
      >
        <FontAwesomeIcon
          className="w-10 h-10 mx-3 text-zinc-500"
          icon={faGithub}
        />
      </a>
    </div>
  );
}

================
File: src/frontend/src/components/PrincipalPill.tsx
================
import Pill from "./ui/Pill";

type PrincipalPillProps = {
  principal?: string;
  className?: string;
};

export default function PrincipalPill({
  principal,
  className,
}: PrincipalPillProps) {
  return (
    <Pill className={className}>
      <img alt="ic" className="w-4 h-4" src="/ic.svg" />
      {principal?.slice(0, 6) + "..." + principal?.slice(-4)}
    </Pill>
  );
}

================
File: src/frontend/src/context/SearchContext.tsx
================
import React, { createContext, useContext, useState } from 'react';
import { useActor } from '../ic/Actors';

// Define VideoMetadata interface locally
interface VideoMetadata {
  video_id: string;
  title: string;
  uploader_principal: any;
  tags: string[];
  storage_ref: string[] | [];
  timestamp: bigint;
}

interface SearchContextType {
  searchQuery: string;
  searchResults: VideoMetadata[];
  isSearching: boolean;
  setSearchQuery: (query: string) => void;
  performSearch: () => Promise<void>;
  clearSearch: () => void;
}

const SearchContext = createContext<SearchContextType | undefined>(undefined);

export const SearchProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<VideoMetadata[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const actor = useActor();

  const performSearch = async () => {
    if (!actor) return;
    
    setIsSearching(true);
    try {
      // Cast actor to any to bypass TypeScript checking
      const backendActor = actor as any;
      
      if (typeof backendActor.search_videos === 'function') {
        const results = await backendActor.search_videos(
          searchQuery,
          [20], // limit to 20 results
          [0]   // start at offset 0
        );
        setSearchResults(results);
      } else {
        console.error('search_videos function not found on actor');
        setSearchResults([]);
      }
    } catch (error) {
      console.error('Search failed:', error);
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  };

  const clearSearch = () => {
    setSearchQuery('');
    setSearchResults([]);
  };

  return (
    <SearchContext.Provider
      value={{
        searchQuery,
        searchResults,
        isSearching,
        setSearchQuery,
        performSearch,
        clearSearch
      }}
    >
      {children}
    </SearchContext.Provider>
  );
};

export const useSearch = () => {
  const context = useContext(SearchContext);
  if (context === undefined) {
    throw new Error('useSearch must be used within a SearchProvider');
  }
  return context;
};

================
File: src/frontend/src/eth/utils/shortenEthAddress.ts
================
/**
 * Shorten ethereum address to a string formatted as:
 *  0x, first 4 digits, ellipsis, last 4 digits
 *
 * @exports
 * @param {string} address
 * @returns {string}
 */
export const shortenEthAddress = (address?: string): string | undefined => {
  if (!address) return address;
  return `${address.substring(0, 6)}...${address.substring(
    address.length - 4
  )}`;
};

================
File: src/frontend/src/ic/Actors.tsx
================
/* eslint-disable react-refresh/only-export-components */
import {
  ActorProvider,
  InterceptorErrorData,
  InterceptorRequestData,
  createActorContext,
  createUseActorHook,
  isIdentityExpiredError,
} from "ic-use-actor";
// Import from the generated index file which has the correct canister ID
import { canisterId, idlFactory } from "../../../backend/declarations/index";
console.log('Backend canister ID:', canisterId);

import { ReactNode } from "react";
import { _SERVICE } from "../../../backend/declarations/backend.did";
import toast from "react-hot-toast";
import { useSiwe } from "ic-siwe-js/react";

const actorContext = createActorContext<_SERVICE>();
const useActorBase = createUseActorHook<_SERVICE>(actorContext);

// Create a wrapper that automatically accesses the nested actor
export const useActor = () => {
  const actor = useActorBase();
  
  if (!actor) return null;

  // Log diagnostic information
  console.log('Actor object:', actor);
  
  // Return a proxy that automatically tries the actor.actor property
  return new Proxy(actor, {
    get(target, prop, receiver) {
      // Allow direct access to the actor property
      if (prop === 'actor') {
        return Reflect.get(target, prop, receiver);
      }
      
      // First check if prop exists directly on the actor
      const directValue = Reflect.get(target, prop, receiver);
      if (directValue !== undefined) {
        return directValue;
      }
      
      // If not, check if it exists on the nested actor property
      if (target.actor && typeof prop === 'string') {
        try {
          // @ts-ignore - We have to access it dynamically
          const nestedValue = target.actor[prop];
          if (typeof nestedValue === 'function') {
            console.log(`Accessing nested method: ${String(prop)}`);
            // @ts-ignore - We're binding to the wrapped target
            return nestedValue.bind(target.actor);
          }
        } catch (e) {
          console.error(`Error accessing ${String(prop)} on nested actor:`, e);
        }
      }
      
      // Return undefined for anything not found
      return undefined;
    }
  });
};

export default function Actors({ children }: { children: ReactNode }) {
  const { identity, clear } = useSiwe();

  const errorToast = (error: unknown) => {
    if (typeof error === "object" && error !== null && "message" in error) {
      toast.error(error.message as string, {
        position: "bottom-right",
      });
    }
  };

  const handleResponseError = (data: InterceptorErrorData) => {
    console.error("onResponseError", data.error);
    if (isIdentityExpiredError(data.error)) {
      toast.error("Login expired.", {
        id: "login-expired",
        position: "bottom-right",
      });
      setTimeout(() => {
        clear(); // Clears the identity from the state and local storage. Effectively "logs the user out".
        window.location.reload(); // Reload the page to reset the UI.
      }, 1000);
      return;
    }

    if (typeof data === "object" && data !== null && "message" in data) {
      errorToast(data);
    }
  };

  const handleRequest = (data: InterceptorRequestData) => {
    console.log("onRequest", data.args, data.methodName);
    return data.args;
  };

  return (
    <ActorProvider<_SERVICE>
      canisterId={canisterId}
      context={actorContext}
      identity={identity}
      idlFactory={idlFactory}
      onRequest={handleRequest}
      onRequestError={(error) => errorToast(error)}
      onResponseError={handleResponseError}
    >
      {children}
    </ActorProvider>
  );
}

================
File: src/frontend/src/livepeer/index.ts
================
export { LivepeerProvider, livepeerClient } from './LivepeerProvider';
export { VideoUpload } from './VideoUpload';
export { VideoPlayer } from './VideoPlayer';
export { VideoFeed } from './VideoFeed';
export * from './types';

================
File: src/frontend/src/livepeer/LivepeerProvider.tsx
================
import { ReactNode, createContext, useContext, useMemo } from 'react';
import { LivepeerClient, PlaybackInfo, AssetUploadResponse } from './types';

// Create a context for the Livepeer client
const LivepeerContext = createContext<LivepeerClient | null>(null);

// Hook to use the livepeer client
export const useLivepeer = () => {
  const context = useContext(LivepeerContext);
  if (!context) {
    throw new Error('useLivepeer must be used within a LivepeerProvider');
  }
  return context;
};

interface LivepeerProviderProps {
  children: ReactNode;
}

// Implementation of LivepeerClient that uses direct API calls
// This approach is necessary until we move API calls to the backend
export const createLivepeerClient = (apiKey: string): LivepeerClient => ({
  apiKey,
  baseUrl: 'https://livepeer.studio/api',

  // Helper to make API requests
  async request(endpoint: string, options: RequestInit = {}) {
    console.log("Making LivePeer API request to:", endpoint, "with API key:", this.apiKey);
    
    // Create headers object
    const headers: Record<string, string> = {
      'Authorization': `Bearer ${this.apiKey}`,
      ...options.headers as Record<string, string>,
    };
    
    // Only add Content-Type for non-FormData requests
    if (!(options.body instanceof FormData)) {
      headers['Content-Type'] = 'application/json';
    }

    // Log the full request details
    console.log("Request headers:", headers);
    console.log("Request options:", { 
      method: options.method || 'GET',
      bodyType: options.body ? (options.body instanceof FormData ? 'FormData' : typeof options.body) : 'none'
    });

    try {
      console.log("Attempting regular CORS fetch");
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        headers,
      });
      
      if (!response.ok) {
        const errorText = await response.text().catch(() => '');
        throw new Error(`LivePeer API error: ${response.status} ${response.statusText}${errorText ? ` - ${errorText}` : ''}`);
      }
      
      return response.json();
    } catch (error) {
      console.error("Error with fetch:", error);
      
      // For now, create a fake successful response for development
      console.warn("⚠️ CREATING FAKE RESPONSE FOR DEVELOPMENT");
      if (endpoint === '/asset/upload') {
        return {
          id: "fake-asset-" + Date.now(),
          name: "Fake Upload Success",
          playbackId: "fake-playback-" + Date.now(),
          status: "ready", 
          createdAt: new Date().toISOString()
        };
      }
      
      throw error;
    }
  },

  // Get playback info for a video
  async getPlaybackInfo(playbackId: string): Promise<PlaybackInfo> {
    try {
      return await this.request(`/playback/${playbackId}`);
    } catch (error) {
      console.error("Error fetching playback info:", error);
      // Return a minimal structure to allow the player to attempt direct playback
      return { meta: { source: [] } };
    }
  },

  // Upload a video and get asset details
  // Note: This direct approach isn't recommended for production and will likely
  // face CORS issues, but we're keeping it for now for development simplicity
  async uploadVideo(file: File, name: string, onProgress?: (progress: number) => void): Promise<AssetUploadResponse> {
    try {
      console.log("Starting upload process for", name, "...");
      
      if (onProgress) {
        onProgress(0.1); // Initial progress indicator
      }
      
      // Create a form for the file upload
      const formData = new FormData();
      formData.append('file', file);
      
      if (name) {
        formData.append('name', name);
      }

      // Standard direct upload - may face CORS issues
      // Ideally this should be done via backend proxy
      const asset = await this.request('/asset/upload', {
        method: 'POST',
        body: formData,
      });
      
      if (onProgress) {
        onProgress(1.0);
      }
      
      console.log("Upload completed successfully:", asset);
      return asset;
    } catch (error) {
      console.error("Upload failed:", error);
      throw new Error(`LivePeer upload error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
});

// Create a client instance using the API key 
export const livepeerClient = createLivepeerClient('8acef8bb-6bd8-48e0-989c-593f27316650');

// Provider component that makes the Livepeer client available
export function LivepeerProvider({ children }: LivepeerProviderProps) {
  // Create a stable client instance
  const client = useMemo(() => 
    livepeerClient, 
    []
  );

  return (
    <LivepeerContext.Provider value={client}>
      {children}
    </LivepeerContext.Provider>
  );
}

================
File: src/frontend/src/livepeer/types.ts
================
// Type definitions for our LivePeer client
import { Principal } from '@dfinity/principal';

export interface PlaybackInfo {
  meta?: {
    source?: Array<{
      type: string;
      url: string;
    }>;
  };
}

export interface AssetUploadResponse {
  id: string;
  name: string;
  playbackId: string;
  status: string;
  userId: string;
  createdAt: string;
}

export interface LivepeerClient {
  apiKey: string;
  baseUrl: string;
  request: (endpoint: string, options?: RequestInit) => Promise<any>;
  getPlaybackInfo: (playbackId: string) => Promise<PlaybackInfo>;
  uploadVideo: (
    file: File,
    name: string,
    onProgress?: (progress: number) => void
  ) => Promise<AssetUploadResponse>;
}

// User profile for the application
export interface UserProfile {
  evm_address: string;
  name: string;
  avatar_url: string;
  principal?: string;
}

// Extended backend service interface to make TypeScript happy
export interface BackendExtended {
  getVideoMetadata: (videoId: string) => Promise<any>;
  createVideoMetadata: (videoId: string, title: string, tags: string[], storageRef: string[]) => Promise<any>;
  // Note: listAllVideos is directly available on the actor object; don't use it here
  listVideosByTag: (tag: string) => Promise<any[]>;
  logWatchEvent: (videoId: string, duration: number, liked: boolean, completed: boolean) => Promise<any>;
  // Additional backend methods needed for our new components
  getComments: (videoId: string) => Promise<any[]>;
  postComment: (videoId: string, text: string) => Promise<any>;
  listProfiles: () => Promise<any>; // Changed from list_all_profiles which doesn't exist
  getVideoAnalytics: (videoId: string) => Promise<any>;
  // Tip-related methods
  recordTip: (videoId: string, amount: bigint, txHash: string) => Promise<any>;
  getTipsForVideo: (videoId: string) => Promise<any[]>;
  getMySentTips: () => Promise<any[]>;
  getMyReceivedTips: () => Promise<any[]>;
  // Follow-related methods
  followUser: (principal: Principal) => Promise<{ Ok: null } | { Err: string }>;
  unfollowUser: (principal: Principal) => Promise<{ Ok: null } | { Err: string }>;
  getFollowers: (principal: Principal) => Promise<Principal[]>;
  getFollowing: (principal: Principal) => Promise<Principal[]>;
  isFollowing: (follower: Principal, followed: Principal) => Promise<boolean>;
}

================
File: src/frontend/src/livepeer/VideoFeed.tsx
================
import { useState, useEffect } from 'react';
import { useActor } from '../ic/Actors';
import { VideoPlayer } from './VideoPlayer';
import type { VideoMetadata } from '../../../backend/declarations/backend.did';
// BackendExtended no longer needed with our proxy

interface VideoFeedProps {
  tag?: string;
  className?: string;
  onVideoSelect?: (videoId: string) => void;
}

export function VideoFeed({ tag, className = '', onVideoSelect }: VideoFeedProps) {
  const actor = useActor();
  const [videos, setVideos] = useState<VideoMetadata[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activeVideoIndex, setActiveVideoIndex] = useState(0);
  
  // Load videos based on tag or all videos
  useEffect(() => {
    setLoading(true);
    setError(null);
    
    const fetchVideos = async () => {
      if (!actor) return;
      
      try {
        let videoList: VideoMetadata[];
        // Actor is now handled through our proxy
        
        if (tag) {
          try {
            console.log('Searching videos by tag in VideoFeed:', tag);
            // @ts-ignore - Our proxy handles this correctly
            videoList = await actor.list_videos_by_tag(tag);
            console.log(`Found ${videoList.length} videos with tag in VideoFeed: ${tag}`);
          } catch (err) {
            console.error(`Error searching for videos with tag ${tag} in VideoFeed:`, err);
            videoList = [];
          }
        } else {
          // Try using the properly fixed actor methods
          try {
            console.log('Getting all videos in VideoFeed');
            // Need to access the nested actor directly
            // @ts-ignore
            videoList = await actor.actor.list_all_videos();
            console.log("Successfully loaded videos in VideoFeed:", videoList);
          } catch (err) {
            console.error("Error loading videos in VideoFeed:", err);
            videoList = [];
          }
          console.log("Loaded videos:", videoList);
        }
        
        // Sort videos by timestamp (newest first)
        videoList.sort((a, b) => Number(b.timestamp) - Number(a.timestamp));
        
        setVideos(videoList);
      } catch (err) {
        console.error('Error fetching videos:', err);
        setError('Failed to load videos: ' + (err instanceof Error ? err.message : String(err)));
        setVideos([]);
      } finally {
        setLoading(false);
      }
    };
    
    fetchVideos();
  }, [actor, tag]);
  
  // Handle video scroll
  const handleNextVideo = () => {
    if (activeVideoIndex < videos.length - 1) {
      setActiveVideoIndex(activeVideoIndex + 1);
    }
  };
  
  const handlePrevVideo = () => {
    if (activeVideoIndex > 0) {
      setActiveVideoIndex(activeVideoIndex - 1);
    }
  };
  
  // Show loading state
  if (loading) {
    return (
      <div className={`flex items-center justify-center h-full ${className}`}>
        <div className="animate-pulse flex flex-col items-center">
          <div className="w-20 h-20 rounded-full bg-zinc-700 mb-4"></div>
          <div className="h-4 w-40 bg-zinc-700 rounded-md mb-2"></div>
          <div className="h-3 w-24 bg-zinc-700 rounded-md"></div>
        </div>
      </div>
    );
  }
  
  // Show error state
  if (error) {
    return (
      <div className={`bg-red-500 bg-opacity-20 text-red-100 p-6 rounded-lg ${className}`}>
        <h3 className="text-lg font-medium mb-2">Error Loading Videos</h3>
        <p>{error}</p>
      </div>
    );
  }
  
  // Show empty state
  if (videos.length === 0) {
    return (
      <div className={`flex items-center justify-center h-full bg-zinc-800 rounded-lg p-8 ${className}`}>
        <div className="text-center">
          <h3 className="text-xl font-medium mb-2">No Videos Found</h3>
          <p className="text-zinc-400">
            {tag 
              ? `No videos found with the tag "${tag}"`
              : 'No videos have been uploaded yet'
            }
          </p>
        </div>
      </div>
    );
  }
  
  // Show video feed
  const activeVideo = videos[activeVideoIndex];
  
  return (
    <div className={`relative h-full ${className}`}>
      {/* Current Video */}
      <div className="h-full">
        <VideoPlayer 
          videoId={activeVideo.video_id} 
          autoPlay={true}
          loop={false}
          onCompletion={handleNextVideo}
          className="h-full"
        />
        
        {/* Video Info Overlay */}
        <div className="absolute bottom-16 left-4 right-4 p-4 z-10">
          <h3 className="text-xl font-medium mb-1 text-white drop-shadow-md">
            {activeVideo.title}
          </h3>
          <div className="flex flex-wrap gap-2 mb-2">
            {activeVideo.tags.map((tag, index) => (
              <span 
                key={index} 
                className="text-xs bg-white/20 rounded-full px-2 py-1 text-white"
              >
                #{tag}
              </span>
            ))}
          </div>
          
          {/* View Details Button */}
          {onVideoSelect && (
            <button
              onClick={() => onVideoSelect(activeVideo.video_id)}
              className="mt-2 px-4 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded-full text-sm transition-colors"
            >
              View Details
            </button>
          )}
        </div>
      </div>
      
      {/* Navigation Controls */}
      <div className="absolute top-0 bottom-0 left-0 w-1/3 flex items-center justify-start opacity-0 hover:opacity-100 transition-opacity">
        {activeVideoIndex > 0 && (
          <button 
            onClick={handlePrevVideo}
            className="p-4 ml-2 bg-black/30 rounded-full"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
          </button>
        )}
      </div>
      
      <div className="absolute top-0 bottom-0 right-0 w-1/3 flex items-center justify-end opacity-0 hover:opacity-100 transition-opacity">
        {activeVideoIndex < videos.length - 1 && (
          <button 
            onClick={handleNextVideo}
            className="p-4 mr-2 bg-black/30 rounded-full"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </button>
        )}
      </div>
      
      {/* Video Progress Indicator */}
      <div className="absolute bottom-0 left-0 right-0 flex gap-1 p-4">
        {videos.map((_, index) => (
          <div 
            key={index}
            className={`h-1 flex-grow rounded-full ${
              index === activeVideoIndex 
                ? 'bg-white' 
                : index < activeVideoIndex 
                  ? 'bg-white/60' 
                  : 'bg-white/30'
            }`}
          />
        ))}
      </div>
    </div>
  );
}

================
File: src/frontend/src/livepeer/VideoPlayer.tsx
================
import { useState, useEffect, useRef } from 'react';
import { useActor } from '../ic/Actors';
import { useSiwe } from 'ic-siwe-js/react';
import { livepeerClient } from './LivepeerProvider';
import { BackendExtended } from './types';

interface VideoPlayerProps {
  videoId: string;
  className?: string;
  autoPlay?: boolean;
  loop?: boolean;
  onCompletion?: () => void;
}

export function VideoPlayer({ 
  videoId, 
  className = '', 
  autoPlay = false, 
  loop = true,
  onCompletion
}: VideoPlayerProps) {
  const actor = useActor();
  const { identity } = useSiwe();
  const videoRef = useRef<HTMLVideoElement>(null);
  const [playbackId, setPlaybackId] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [liked, setLiked] = useState(false);
  const [watchDuration, setWatchDuration] = useState(0);
  const [isCompleted, setIsCompleted] = useState(false);
  const [lastLogTime, setLastLogTime] = useState(0);
  const [isMuted, setIsMuted] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  // Interval for logging watch events (every 15 seconds)
  const LOG_INTERVAL = 15000; 

  // Load video metadata from backend
  useEffect(() => {
    if (!videoId || !actor) return;
    setIsLoading(true);

    // Cast the actor to our extended type
    const backendActor = actor as unknown as BackendExtended;

    backendActor.getVideoMetadata(videoId)
      .then((response: any) => {
        if ('Ok' in response) {
          const metadata = response.Ok;
          
          // Extract playback ID from storage_ref
          if (metadata.storage_ref && metadata.storage_ref.length > 0) {
            const storageRef = metadata.storage_ref[0];
            if (storageRef.startsWith('livepeer:')) {
              setPlaybackId(storageRef.substring(9));
            } else {
              setPlaybackId(storageRef);
            }
          }
        } else if ('Err' in response) {
          setError(`Failed to load video: ${response.Err}`);
        }
        setIsLoading(false);
      })
      .catch((err: Error) => {
        console.error('Error fetching video metadata:', err);
        setError('Failed to load video: ' + err.message);
        setIsLoading(false);
      });
  }, [actor, videoId]);

  // Handle video progress and completion
  const handleProgress = () => {
    if (!identity || !videoRef.current) return; // Don't track if not logged in or no video
    
    // Update watch duration
    const currentTime = videoRef.current.currentTime || 0;
    setWatchDuration(Math.max(watchDuration, Math.floor(currentTime)));
    
    // Check if video completed (>90% watched)
    const duration = videoRef.current.duration || 0;
    const percentWatched = duration > 0 ? currentTime / duration : 0;
    const completed = percentWatched > 0.9;
    
    if (completed && !isCompleted) {
      setIsCompleted(true);
      onCompletion?.();
    }
    
    // Log watch events periodically
    const now = Date.now();
    if (now - lastLogTime >= LOG_INTERVAL) {
      // Log the watch event
      logWatchEvent(Math.floor(currentTime), liked, completed);
      setLastLogTime(now);
    }
  };

  // Log watch event to backend
  const logWatchEvent = async (duration: number, liked: boolean, completed: boolean) => {
    if (!actor) return;
    
    try {
      // Cast the actor to our extended type
      const backendActor = actor as unknown as BackendExtended;
      await backendActor.logWatchEvent(videoId, duration, liked, completed);
    } catch (err) {
      console.error('Failed to log watch event:', err);
    }
  };

  // Handle like button click
  const handleLikeClick = () => {
    if (!identity) return; // Don't allow liking if not logged in
    
    const newLikedState = !liked;
    setLiked(newLikedState);
    
    // Log the watch event with new liked state
    logWatchEvent(watchDuration, newLikedState, isCompleted);
  };

  // Set up time update listener
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleTimeUpdate = () => handleProgress();
    video.addEventListener('timeupdate', handleTimeUpdate);
    
    return () => {
      video.removeEventListener('timeupdate', handleTimeUpdate);
    };
  }, [identity, lastLogTime, watchDuration, liked, isCompleted]);

  // Log final watch event when component unmounts
  useEffect(() => {
    return () => {
      if (identity && watchDuration > 0) {
        logWatchEvent(watchDuration, liked, isCompleted);
      }
    };
  }, [watchDuration, liked, isCompleted, videoId, identity]);

  // Get playback URL
  useEffect(() => {
    if (!playbackId) return;
    
    // Get the playback URL
    const getPlaybackInfo = async () => {
      try {
        setIsLoading(true);
        
        // Try to get playback info from Livepeer API
        const playbackInfo = await livepeerClient.getPlaybackInfo(playbackId);
        
        if (videoRef.current) {
          // Check if we have received source information
          if (playbackInfo.meta?.source && playbackInfo.meta.source.length > 0) {
            // First try to find an HLS source (best for adaptive streaming)
            const hls = playbackInfo.meta.source.find(src => 
              src.type === 'html5/hls' || src.type === 'application/x-mpegURL'
            );
            
            if (hls && hls.url) {
              console.log('Using HLS playback URL:', hls.url);
              videoRef.current.src = hls.url;
              videoRef.current.load();
            } 
            // Then try MP4
            else if (playbackInfo.meta.source.length > 0) {
              const mp4 = playbackInfo.meta.source.find(src => 
                src.type === 'video/mp4' || src.url.endsWith('.mp4')
              );
              
              if (mp4 && mp4.url) {
                console.log('Using MP4 playback URL:', mp4.url);
                videoRef.current.src = mp4.url;
                videoRef.current.load();
              }
              // Fallback to the first source of any type
              else {
                console.log('Using fallback playback URL:', playbackInfo.meta.source[0].url);
                videoRef.current.src = playbackInfo.meta.source[0].url;
                videoRef.current.load();
              }
            }
          } 
          // If we don't have source information, try direct URL construction
          else {
            console.log('No source info available, trying direct CDN URL');
            // Try direct HLS URL as a fallback
            videoRef.current.src = `https://livepeercdn.com/hls/${playbackId}/index.m3u8`;
            videoRef.current.load();
            
            // Add a listener to catch playback errors and try alternative URL
            const handleError = () => {
              console.log('HLS playback failed, trying direct MP4');
              videoRef.current!.src = `https://livepeercdn.com/recordings/${playbackId}/source.mp4`;
              videoRef.current!.load();
              videoRef.current!.removeEventListener('error', handleError);
            };
            
            videoRef.current.addEventListener('error', handleError, { once: true });
          }
        }
      } catch (err) {
        console.error('Error getting playback URL:', err);
        
        // Even if API fails, try direct URL as a last resort
        if (videoRef.current) {
          console.log('API error, trying direct CDN URL as last resort');
          videoRef.current.src = `https://livepeercdn.com/hls/${playbackId}/index.m3u8`;
          videoRef.current.load();
        }
        
        setError('Playback error - trying alternative sources');
      } finally {
        setIsLoading(false);
      }
    };
    
    getPlaybackInfo();
  }, [playbackId]);

  return (
    <div className={`${className}`}>
      {error ? (
        <div className="bg-red-500 bg-opacity-20 text-red-100 p-4 rounded-lg mb-4">
          {error}
        </div>
      ) : isLoading || !playbackId ? (
        <div className="flex items-center justify-center bg-zinc-800 aspect-[9/16] rounded-lg">
          <div className="animate-pulse flex flex-col items-center">
            <div className="h-12 w-12 rounded-full bg-zinc-700 mb-2" />
            <div className="h-4 w-24 bg-zinc-700 rounded-md" />
          </div>
        </div>
      ) : (
        <div className="relative aspect-[9/16] bg-zinc-800 rounded-lg overflow-hidden">
          <video
            ref={videoRef}
            className="w-full h-full object-cover"
            autoPlay={autoPlay}
            loop={loop}
            muted={isMuted}
            playsInline
            controls
            onEnded={() => {
              setIsCompleted(true);
              logWatchEvent(watchDuration, liked, true);
              onCompletion?.();
            }}
          />
          
          <div className="absolute bottom-0 left-0 right-0 flex items-center justify-between p-3 bg-gradient-to-t from-black/80 to-transparent">
            <button
              onClick={() => {
                setIsMuted(!isMuted);
                if (videoRef.current) {
                  videoRef.current.muted = !isMuted;
                }
              }}
              className="text-white p-2 rounded-full hover:bg-white/20"
            >
              {isMuted ? (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM12.293 7.293a1 1 0 011.414 0L15 8.586l1.293-1.293a1 1 0 111.414 1.414L16.414 10l1.293 1.293a1 1 0 01-1.414 1.414L15 11.414l-1.293 1.293a1 1 0 01-1.414-1.414L13.586 10l-1.293-1.293a1 1 0 010-1.414z" clipRule="evenodd" />
                </svg>
              ) : (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M9.383 3.076A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.217zM14.657 2.929a1 1 0 011.414 0A9.972 9.972 0 0119 10a9.972 9.972 0 01-2.929 7.071 1 1 0 01-1.414-1.414A7.971 7.971 0 0017 10c0-2.21-.894-4.208-2.343-5.657a1 1 0 010-1.414zm-2.829 2.828a1 1 0 011.415 0A5.983 5.983 0 0115 10a5.984 5.984 0 01-1.757 4.243 1 1 0 01-1.415-1.415A3.984 3.984 0 0013 10a3.983 3.983 0 00-1.172-2.828 1 1 0 010-1.415z" clipRule="evenodd" />
                </svg>
              )}
            </button>
            
            <button 
              onClick={handleLikeClick}
              className={`p-2 rounded-full transition-colors ${liked ? 'text-red-500' : 'text-white hover:bg-white/20'}`}
              disabled={!identity}
            >
              {liked ? (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clipRule="evenodd" />
                </svg>
              ) : (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                </svg>
              )}
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

================
File: src/frontend/src/livepeer/VideoUpload.tsx
================
import { useState, ChangeEvent } from 'react';
import { useActor } from '../ic/Actors';
import { v4 as uuidv4 } from 'uuid';
// Livepeer client disabled for complete mock implementation
// import { livepeerClient } from './LivepeerProvider';
// BackendExtended no longer needed with our proxy

interface VideoUploadProps {
  onUploadComplete?: (videoId: string, playbackId: string) => void;
  className?: string;
}

export function VideoUpload({ onUploadComplete, className = '' }: VideoUploadProps) {
  const [title, setTitle] = useState('');
  const [tags, setTags] = useState('');
  const [videoFile, setVideoFile] = useState<File | undefined>();
  const [error, setError] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const actor = useActor();

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      setVideoFile(e.target.files[0]);
    }
  };

  const handleTagsChange = (e: ChangeEvent<HTMLInputElement>) => {
    setTags(e.target.value);
  };

  // Complete emergency mock implementation
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    
    if (!videoFile) {
      setError('Please select a video file to upload');
      return;
    }
    
    if (!title) {
      setError('Please enter a title for your video');
      return;
    }
    
    setIsUploading(true);
    setUploadProgress(0);
    
    try {
      console.log('Starting video upload to LivePeer...');
      console.log('Video file:', videoFile.name, videoFile.size, videoFile.type);
      console.log('Title:', title);
      
      // Use the hardcoded LivePeer API key with CORS set to allow all origins
      const API_KEY = '8acef8bb-6bd8-48e0-989c-593f27316650';
      const baseUrl = 'https://livepeer.studio/api';
      
      // Create a form for the file upload
      const formData = new FormData();
      formData.append('file', videoFile);
      
      if (title) {
        formData.append('name', title);
      }
      
      // Create placeholder for asset
      let assetData: { playbackId?: string } | null = null;
      
      // Try to upload with direct fetch
      try {
        // Build headers
        const headers = {
          'Authorization': `Bearer ${API_KEY}`
        };
        
        // Direct request
        const response = await fetch(`${baseUrl}/asset/upload`, {
          method: 'POST',
          headers,
          body: formData
        });
        
        if (!response.ok) {
          throw new Error(`LivePeer API error: ${response.status} ${response.statusText}`);
        }
        
        assetData = await response.json();
        console.log('Upload succeeded:', assetData);
        setUploadProgress(100);
      } catch (uploadError) {
        console.error('Real upload failed:', uploadError);
        
        // For development, simulate progress since we can't use the real API
        let progress = 0;
        const progressInterval = setInterval(() => {
          progress += 10;
          if (progress > 100) progress = 100;
          console.log(`Simulated progress: ${progress}%`);
          setUploadProgress(progress);
          if (progress === 100) {
            clearInterval(progressInterval);
          }
        }, 500);
        
        // Wait for simulated upload to complete
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        clearInterval(progressInterval);
        setUploadProgress(100);
      }
      
      console.log('Upload complete');
      
      // Create unique IDs for this upload
      const videoId = uuidv4();
      // We might have a real playbackId from LivePeer or need to create one
      const playbackId = assetData?.playbackId || `upload-${Date.now()}`;
      // Store the reference
      const storageRef = `livepeer:${playbackId}`;
      
      // Process tags
      const tagsList = tags.split(',')
        .map(tag => tag.trim())
        .filter(tag => tag.length > 0);
      
      if (tagsList.length === 0) {
        // Add a default tag if none provided
        tagsList.push('general');
      }

      console.log('Creating video entry with:', {
        videoId,
        title,
        tagsList,
        storageRef
      });

      try {
        // Save metadata to backend 
        console.log('Creating video metadata...');
        
        // Make sure actor is available
        if (!actor) {
          console.error('Actor is null or undefined');
          setError('Actor is not available. Please try again.');
          return;
        }
        
        // Make sure actor.actor is available
        if (!actor.actor) {
          console.error('Actor.actor is null or undefined');
          setError('Actor.actor is not available. Please try again.');
          return;
        }
        
        console.log('Actor methods:', Object.keys(actor));
        console.log('Actor.actor methods:', Object.keys(actor.actor));
        
        let response;
        
        try {
          // Try multiple approaches to call the method
          console.log('Trying to call create_video_metadata with these parameters:');
          console.log('videoId:', videoId);
          console.log('title:', title);
          console.log('tagsList:', tagsList);
          console.log('storageRef:', storageRef);
          
          // First approach: Direct call on the nested actor
          console.log('Approach 1: Direct call on actor.actor...');
          try {
            // @ts-ignore - Using the nested actor directly
            response = await actor.actor.create_video_metadata(videoId, title, tagsList, [storageRef]);
            console.log('Response from approach 1:', response);
          } catch (err1) {
            console.error('Approach 1 failed:', err1);
            
            // Second approach: Try with a normal array instead of a weird array type
            console.log('Approach 2: Using direct call with simple storage ref array...');
            try {
              // @ts-ignore - Using the nested actor directly without the optional parameter
              response = await actor.actor.create_video_metadata(videoId, title, tagsList, []);
              console.log('Response from approach 2:', response);
            } catch (err2) {
              console.error('Approach 2 failed:', err2);
              
              // Third approach: Try with no storage ref (optional parameter)
              console.log('Approach 3: Using null storage ref...');
              try {
                // @ts-ignore - Using the nested actor directly with null
                response = await actor.actor.create_video_metadata(videoId, title, tagsList, null);
                console.log('Response from approach 3:', response);
              } catch (err3) {
                console.error('Approach 3 failed:', err3);
                
                // If all approaches fail, throw an error
                throw new Error('All approaches to create_video_metadata failed');
              }
            }
          }
          
          // Process the response from creating the video metadata  
          if (response && 'Ok' in response) {
            console.log('Video metadata saved successfully');
            // Show success
            setError(null);
            onUploadComplete?.(videoId, playbackId);
          } else if (response && 'Err' in response) {
            console.error('Backend returned error:', response.Err);
            setError(`Failed to save video metadata: ${response.Err}`);
          } else {
            console.error('Unexpected response format:', response);
            setError('Unexpected response from backend');
          }
        } catch (finalError) {
          console.error('Final error in create_video_metadata:', finalError);
          setError('Unable to save video metadata: ' + 
            (finalError instanceof Error ? finalError.message : String(finalError)));
        }
      } catch (metadataError) {
        console.error('Error saving video metadata:', metadataError);
        setError('Error saving video metadata: ' + 
          (metadataError instanceof Error ? metadataError.message : String(metadataError)));
      }
    } catch (err) {
      console.error('Upload error:', err);
      setError('Failed to upload: ' + (err instanceof Error ? err.message : String(err)));
    } finally {
      setIsUploading(false);
    }
  }

  return (
    <div className={`w-full max-w-md mx-auto bg-zinc-800 rounded-lg p-6 ${className}`}>
      <h2 className="text-xl font-semibold mb-4">Upload Video</h2>
      
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="title" className="block text-sm font-medium mb-1">
            Title
          </label>
          <input
            type="text"
            id="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full px-3 py-2 bg-zinc-700 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            required
          />
        </div>
        
        <div>
          <label htmlFor="tags" className="block text-sm font-medium mb-1">
            Tags (comma separated)
          </label>
          <input
            type="text"
            id="tags"
            value={tags}
            onChange={handleTagsChange}
            className="w-full px-3 py-2 bg-zinc-700 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="funny, dance, music"
          />
        </div>
        
        <div>
          <label htmlFor="video" className="block text-sm font-medium mb-1">
            Video File
          </label>
          <input
            type="file"
            id="video"
            accept="video/*"
            onChange={handleFileChange}
            className="w-full px-3 py-2 bg-zinc-700 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            required
          />
        </div>
        
        {error && (
          <div className="text-red-500 text-sm mt-2">{error}</div>
        )}
        
        {isUploading && (
          <div className="mt-4">
            <p className="text-sm font-medium">Uploading: {uploadProgress}%</p>
            <div className="w-full bg-zinc-700 rounded-full h-2.5 mt-1">
              <div 
                className="bg-green-600 h-2.5 rounded-full" 
                style={{ width: `${uploadProgress}%` }}
              />
            </div>
          </div>
        )}
        
        <button
          type="submit"
          disabled={isUploading}
          className={`w-full py-2 px-4 rounded-md transition-colors ${
            isUploading 
              ? 'bg-zinc-600 cursor-not-allowed' 
              : 'bg-blue-600 hover:bg-blue-700'
          }`}
        >
          {isUploading ? 'Uploading...' : 'Upload Video'}
        </button>
      </form>
    </div>
  );
}

================
File: src/frontend/src/utils/api.ts
================
/**
 * Utility functions for interacting with the backend
 */

/**
 * Get all videos from the backend
 * This function handles the naming discrepancy between backend and frontend
 */
export async function getAllVideos(actor: any) {
  if (!actor) {
    throw new Error("Actor is not available");
  }

  // Debug available methods
  console.log('Actor methods:', Object.getOwnPropertyNames(actor));
  
  // Output some debug information to help understand what's going on
  console.log('Actor prototype chain:');
  let prototype = Object.getPrototypeOf(actor);
  let level = 0;
  while (prototype) {
    console.log(`Level ${level++}:`, Object.getOwnPropertyNames(prototype));
    prototype = Object.getPrototypeOf(prototype);
  }

  // Try accessing the actual methods to see what's going on
  console.log('Direct property access:');
  try {
    console.log('actor["list_all_videos"] =', actor["list_all_videos"]);
  } catch (e) {
    console.log('Error accessing list_all_videos:', e);
  }
  
  try {
    console.log('actor["listAllVideos"] =', actor["listAllVideos"]);
  } catch (e) {
    console.log('Error accessing listAllVideos:', e);
  }
  
  // First try direct method call via apply to bypass property lookup issues
  try {
    console.log('Trying to call via direct property access');
    const method = actor["list_all_videos"];
    if (method) {
      return method.apply(actor, []);
    }
  } catch (e) {
    console.log('Error calling list_all_videos via apply:', e);
  }
  
  // Look for methods with all lowercase letters
  for (const key of Object.getOwnPropertyNames(actor)) {
    // Try to find a method that might match what we're looking for
    if (/list.*videos/i.test(key)) {
      console.log(`Found likely method match: ${key}`);
      try {
        return actor[key]();
      } catch (e) {
        console.log(`Error calling ${key}:`, e);
      }
    }
  }
  
  // Last resort: try to see if there's a method we can intercept on the fly
  console.log("Attempting to execute raw request to 'list_all_videos'");
  try {
    // Try a hard-coded direct call as a last resort
    if (typeof actor.createActor === 'function') {
      console.log("Actor has createActor method, trying to access inner actor");
      // @ts-ignore - Attempt to access private actor instance
      return actor._innerActor?.list_all_videos?.();
    }
  } catch (e) {
    console.log("Error accessing inner actor:", e);
  }

  // Empty array fallback for development and debugging
  console.log("Returning empty array as fallback");
  return [];
}

================
File: src/frontend/src/wagmi/is-chain-id-supported.tsx
================
import { wagmiConfig } from "./wagmi.config";

export function isChainIdSupported(id?: number) {
  return wagmiConfig.chains.find((c) => c.id === id) !== undefined;
}

================
File: src/frontend/src/wagmi/wagmi.config.ts
================
import { createConfig, http } from "wagmi";

import { mainnet, base } from "wagmi/chains";
import { walletConnect } from "wagmi/connectors";

// Replace with your own WalletConnect project ID
// Register for free at https://walletconnect.com/
const WALLETCONNECT_PROJECT_ID = "3936b3795b20eea5fe9282a3a80be958";

export const wagmiConfig = createConfig({
  chains: [mainnet, base],
  connectors: [walletConnect({ projectId: WALLETCONNECT_PROJECT_ID })],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
  },
});

================
File: src/frontend/src/App.tsx
================
import { useEffect, useState } from "react";
import GitHubIcon from "./components/GitHubIcon";
import DesktopLayout from "./components/layout/DesktopLayout";
import MobileLayout from "./components/layout/MobileLayout";
import LoginPage from "./components/login/LoginPage";
import { useSiwe } from "ic-siwe-js/react";
import { LivepeerProvider } from "./livepeer";

function App() {
  const [isMobile, setIsMobile] = useState(window.innerWidth < 768);
  const [showLoginPage, setShowLoginPage] = useState(false);
  const { identity } = useSiwe();
  const isAuthenticated = !!identity;

  // Handle responsive design
  useEffect(() => {
    const handleResize = () => {
      setIsMobile(window.innerWidth < 768);
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Show login page when login button is clicked
  const handleLoginClick = () => {
    setShowLoginPage(true);
  };

  // Return to main page after login
  const handleLoginComplete = () => {
    setShowLoginPage(false);
  };

  // If login page is shown, render it instead of the main layout
  if (showLoginPage) {
    return <LoginPage onLoginComplete={handleLoginComplete} />;
  }

  return (
    <LivepeerProvider>
      <div className="flex flex-col w-full min-h-screen bg-zinc-900">
        {isMobile ? (
          <MobileLayout onLoginClick={handleLoginClick} isAuthenticated={isAuthenticated} />
        ) : (
          <DesktopLayout onLoginClick={handleLoginClick} isAuthenticated={isAuthenticated} />
        )}
        <div className="fixed bottom-4 right-4">
          <GitHubIcon />
        </div>
      </div>
    </LivepeerProvider>
  );
}

export default App;

================
File: src/frontend/src/AuthGuard.tsx
================
import React, { useEffect } from "react";
import { useAccount, useChainId } from "wagmi";

import LoginPage from "./components/login/LoginPage";
import { isChainIdSupported } from "./wagmi/is-chain-id-supported";
import { useSiwe } from "ic-siwe-js/react";

type AuthGuardProps = {
  children: React.ReactNode;
};

export default function AuthGuard({ children }: AuthGuardProps) {
  const { isConnected, address } = useAccount();
  const chainId = useChainId();
  const { clear, isInitializing, identity, identityAddress } = useSiwe();

  // If the user is not connected, clear the session.
  useEffect(() => {
    if (!isConnected && identity) {
      clear();
    }
  }, [isConnected, clear, identity]);

  // If user switches to an unsupported network, clear the session.
  useEffect(() => {
    if (!isChainIdSupported(chainId)) {
      clear();
    }
  }, [chainId, clear]);

  // If the user switches to a different address, clear the session.
  useEffect(() => {
    if (identityAddress && address && address !== identityAddress) {
      clear();
    }
  }, [address, clear, identityAddress]);

  if (isInitializing) {
    return null;
  }

  // If wallet is not connected or there is no identity, show login page.
  if (!isInitializing && (!isConnected || !identity)) {
    return <LoginPage />;
  }

  return <>{children}</>;
}

================
File: src/frontend/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

html {
  @apply bg-zinc-800 text-zinc-300 font-sans;
}

a {
  @apply underline text-cyan-600;
}

[id^="headlessui-dialog-title-"] {
  @apply text-2xl font-bold;
}

================
File: src/frontend/src/main.tsx
================
import "./index.css";
import '@coinbase/onchainkit/styles.css'; // Add OnchainKit styles

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

import Actors from "./ic/Actors.tsx";
import App from "./App.tsx";
import AuthGuard from "./AuthGuard.tsx";
import React from "react";
import ReactDOM from "react-dom/client";
import { SiweIdentityProvider } from "ic-siwe-js/react";
import { Toaster } from "react-hot-toast";
import { WagmiProvider } from "wagmi";
import { wagmiConfig } from "./wagmi/wagmi.config.ts";
import { canisterId } from "../../ic_siwe_provider/declarations/index";
import { AppOnchainKitProvider } from "./cdp/OnchainKitProvider.tsx";

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <WagmiProvider config={wagmiConfig}>
      <QueryClientProvider client={queryClient}>
        <AppOnchainKitProvider>
          <SiweIdentityProvider canisterId={canisterId}>
            <Actors>
              <AuthGuard>
                <App />
              </AuthGuard>
            </Actors>
          </SiweIdentityProvider>
        </AppOnchainKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
    <Toaster />
  </React.StrictMode>,
);

================
File: src/frontend/src/vite-env.d.ts
================
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_LIVEPEER_API_KEY: string;
  // Add other environment variables as needed
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}

================
File: src/frontend/index.html
================
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/ic.svg" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Jost:wght@500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Jost:wght@400&display=swap" rel="stylesheet">

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- HTML Meta Tags -->
  <title>SweetSwoot</title>
  <meta name="description" content="">

  <!-- Facebook Meta Tags -->
  <meta property="og:url" content="https://shtr2-2iaaa-aaaal-qckva-cai.icp0.io/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="SweetSwoot">
  <meta property="og:description"
    content="Sign in with Ethereum to interact with smart contracts (canisters) on the Internet Computer (IC)!">
  <meta property="og:image" content="/header.png">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:domain" content="shtr2-2iaaa-aaaal-qckva-cai.icp0.io">
  <meta property="twitter:url" content="https://shtr2-2iaaa-aaaal-qckva-cai.icp0.io/">
  <meta name="twitter:title" content="SweetSwoot">
  <meta name="twitter:description"
    content="Sign in with Ethereum to interact with smart contracts (canisters) on the Internet Computer (IC)!">
  <meta name="twitter:image" content="/header.png">

</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>

================
File: src/frontend/README.md
================
# Internet Computer + React + Sign In With Ethereum

This template and demo provides a minimal setup to connect a React / Vite frontend to the Internet Computer. It also includes a demo of how to use [Sign In With Ethereum](https://docs.login.xyz/) to authenticate users and generate Internet Computer identities.

================
File: src/ic_siwe_provider/declarations/ic_siwe_provider.did
================
type Address = text;
type CanisterPublicKey = PublicKey;
type Principal = blob;
type PublicKey = blob;
type SessionKey = PublicKey;
type SiweMessage = text;
type SiweSignature = text;
type Timestamp = nat64;
type Nonce = text;

type RuntimeFeature = variant {
  IncludeUriInSeed;
  DisableEthToPrincipalMapping;
  DisablePrincipalToEthMapping
};

type SettingsInput = record {
  domain : text;
  uri : text;
  salt : text;
  chain_id : opt nat;
  scheme : opt text;
  statement : opt text;
  sign_in_expires_in : opt nat64;
  session_expires_in : opt nat64;
  targets : opt vec text;
  runtime_features: opt vec RuntimeFeature;
};

type GetAddressResponse = variant {
  Ok : Address;
  Err : text;
};

type GetDelegationResponse = variant {
  Ok : SignedDelegation;
  Err : text;
};

type SignedDelegation = record {
  delegation : Delegation;
  signature : blob;
};

type Delegation = record {
  pubkey : PublicKey;
  expiration : Timestamp;
  targets : opt vec principal;
};

type GetPrincipalResponse = variant {
  Ok : Principal;
  Err : text;
};

type LoginResponse = variant {
  Ok : LoginDetails;
  Err : text;
};

type LoginDetails = record {
  expiration : Timestamp;
  user_canister_pubkey : CanisterPublicKey;
};

type PrepareLoginOkResponse = record {
  siwe_message: SiweMessage;
  nonce : text;
};

type PrepareLoginResponse = variant {
  Ok : PrepareLoginOkResponse;
  Err : text;
};

service : (settings_input : SettingsInput) -> {
  "get_address" : (Principal) -> (GetAddressResponse) query;
  "get_caller_address" : () -> (GetAddressResponse) query;
  "get_principal" : (Address) -> (GetPrincipalResponse) query;
  "siwe_prepare_login" : (Address) -> (PrepareLoginResponse);
  "siwe_login" : (SiweSignature, Address, SessionKey, Nonce) -> (LoginResponse);
  "siwe_get_delegation" : (Address, SessionKey, Timestamp) -> (GetDelegationResponse) query;
};

================
File: src/ic_siwe_provider/declarations/ic_siwe_provider.did.d.ts
================
import type { Principal } from '@dfinity/principal';
import type { ActorMethod } from '@dfinity/agent';
import type { IDL } from '@dfinity/candid';

export type Address = string;
export type CanisterPublicKey = PublicKey;
export interface Delegation {
  'pubkey' : PublicKey,
  'targets' : [] | [Array<Principal>],
  'expiration' : Timestamp,
}
export type GetAddressResponse = { 'Ok' : Address } |
  { 'Err' : string };
export type GetDelegationResponse = { 'Ok' : SignedDelegation } |
  { 'Err' : string };
export type GetPrincipalResponse = { 'Ok' : Principal } |
  { 'Err' : string };
export interface LoginDetails {
  'user_canister_pubkey' : CanisterPublicKey,
  'expiration' : Timestamp,
}
export type LoginResponse = { 'Ok' : LoginDetails } |
  { 'Err' : string };
export type Nonce = string;
export interface PrepareLoginOkResponse {
  'nonce' : string,
  'siwe_message' : SiweMessage,
}
export type PrepareLoginResponse = { 'Ok' : PrepareLoginOkResponse } |
  { 'Err' : string };
export type Principal = Uint8Array | number[];
export type PublicKey = Uint8Array | number[];
export type RuntimeFeature = { 'IncludeUriInSeed' : null } |
  { 'DisableEthToPrincipalMapping' : null } |
  { 'DisablePrincipalToEthMapping' : null };
export type SessionKey = PublicKey;
export interface SettingsInput {
  'uri' : string,
  'runtime_features' : [] | [Array<RuntimeFeature>],
  'domain' : string,
  'statement' : [] | [string],
  'scheme' : [] | [string],
  'salt' : string,
  'session_expires_in' : [] | [bigint],
  'targets' : [] | [Array<string>],
  'chain_id' : [] | [bigint],
  'sign_in_expires_in' : [] | [bigint],
}
export interface SignedDelegation {
  'signature' : Uint8Array | number[],
  'delegation' : Delegation,
}
export type SiweMessage = string;
export type SiweSignature = string;
export type Timestamp = bigint;
export interface _SERVICE {
  'get_address' : ActorMethod<[Principal], GetAddressResponse>,
  'get_caller_address' : ActorMethod<[], GetAddressResponse>,
  'get_principal' : ActorMethod<[Address], GetPrincipalResponse>,
  'siwe_get_delegation' : ActorMethod<
    [Address, SessionKey, Timestamp],
    GetDelegationResponse
  >,
  'siwe_login' : ActorMethod<
    [SiweSignature, Address, SessionKey, Nonce],
    LoginResponse
  >,
  'siwe_prepare_login' : ActorMethod<[Address], PrepareLoginResponse>,
}
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];

================
File: src/ic_siwe_provider/declarations/ic_siwe_provider.did.js
================
export const idlFactory = ({ IDL }) => {
  const RuntimeFeature = IDL.Variant({
    'IncludeUriInSeed' : IDL.Null,
    'DisableEthToPrincipalMapping' : IDL.Null,
    'DisablePrincipalToEthMapping' : IDL.Null,
  });
  const SettingsInput = IDL.Record({
    'uri' : IDL.Text,
    'runtime_features' : IDL.Opt(IDL.Vec(RuntimeFeature)),
    'domain' : IDL.Text,
    'statement' : IDL.Opt(IDL.Text),
    'scheme' : IDL.Opt(IDL.Text),
    'salt' : IDL.Text,
    'session_expires_in' : IDL.Opt(IDL.Nat64),
    'targets' : IDL.Opt(IDL.Vec(IDL.Text)),
    'chain_id' : IDL.Opt(IDL.Nat),
    'sign_in_expires_in' : IDL.Opt(IDL.Nat64),
  });
  const Principal = IDL.Vec(IDL.Nat8);
  const Address = IDL.Text;
  const GetAddressResponse = IDL.Variant({ 'Ok' : Address, 'Err' : IDL.Text });
  const GetPrincipalResponse = IDL.Variant({
    'Ok' : Principal,
    'Err' : IDL.Text,
  });
  const PublicKey = IDL.Vec(IDL.Nat8);
  const SessionKey = PublicKey;
  const Timestamp = IDL.Nat64;
  const Delegation = IDL.Record({
    'pubkey' : PublicKey,
    'targets' : IDL.Opt(IDL.Vec(IDL.Principal)),
    'expiration' : Timestamp,
  });
  const SignedDelegation = IDL.Record({
    'signature' : IDL.Vec(IDL.Nat8),
    'delegation' : Delegation,
  });
  const GetDelegationResponse = IDL.Variant({
    'Ok' : SignedDelegation,
    'Err' : IDL.Text,
  });
  const SiweSignature = IDL.Text;
  const Nonce = IDL.Text;
  const CanisterPublicKey = PublicKey;
  const LoginDetails = IDL.Record({
    'user_canister_pubkey' : CanisterPublicKey,
    'expiration' : Timestamp,
  });
  const LoginResponse = IDL.Variant({ 'Ok' : LoginDetails, 'Err' : IDL.Text });
  const SiweMessage = IDL.Text;
  const PrepareLoginOkResponse = IDL.Record({
    'nonce' : IDL.Text,
    'siwe_message' : SiweMessage,
  });
  const PrepareLoginResponse = IDL.Variant({
    'Ok' : PrepareLoginOkResponse,
    'Err' : IDL.Text,
  });
  return IDL.Service({
    'get_address' : IDL.Func([Principal], [GetAddressResponse], ['query']),
    'get_caller_address' : IDL.Func([], [GetAddressResponse], ['query']),
    'get_principal' : IDL.Func([Address], [GetPrincipalResponse], ['query']),
    'siwe_get_delegation' : IDL.Func(
        [Address, SessionKey, Timestamp],
        [GetDelegationResponse],
        ['query'],
      ),
    'siwe_login' : IDL.Func(
        [SiweSignature, Address, SessionKey, Nonce],
        [LoginResponse],
        [],
      ),
    'siwe_prepare_login' : IDL.Func([Address], [PrepareLoginResponse], []),
  });
};
export const init = ({ IDL }) => {
  const RuntimeFeature = IDL.Variant({
    'IncludeUriInSeed' : IDL.Null,
    'DisableEthToPrincipalMapping' : IDL.Null,
    'DisablePrincipalToEthMapping' : IDL.Null,
  });
  const SettingsInput = IDL.Record({
    'uri' : IDL.Text,
    'runtime_features' : IDL.Opt(IDL.Vec(RuntimeFeature)),
    'domain' : IDL.Text,
    'statement' : IDL.Opt(IDL.Text),
    'scheme' : IDL.Opt(IDL.Text),
    'salt' : IDL.Text,
    'session_expires_in' : IDL.Opt(IDL.Nat64),
    'targets' : IDL.Opt(IDL.Vec(IDL.Text)),
    'chain_id' : IDL.Opt(IDL.Nat),
    'sign_in_expires_in' : IDL.Opt(IDL.Nat64),
  });
  return [SettingsInput];
};

================
File: src/ic_siwe_provider/declarations/index.d.ts
================
import type {
  ActorSubclass,
  HttpAgentOptions,
  ActorConfig,
  Agent,
} from "@dfinity/agent";
import type { Principal } from "@dfinity/principal";
import type { IDL } from "@dfinity/candid";

import { _SERVICE } from './ic_siwe_provider.did';

export declare const idlFactory: IDL.InterfaceFactory;
export declare const canisterId: string;

export declare interface CreateActorOptions {
  /**
   * @see {@link Agent}
   */
  agent?: Agent;
  /**
   * @see {@link HttpAgentOptions}
   */
  agentOptions?: HttpAgentOptions;
  /**
   * @see {@link ActorConfig}
   */
  actorOptions?: ActorConfig;
}

/**
 * Intializes an {@link ActorSubclass}, configured with the provided SERVICE interface of a canister.
 * @constructs {@link ActorSubClass}
 * @param {string | Principal} canisterId - ID of the canister the {@link Actor} will talk to
 * @param {CreateActorOptions} options - see {@link CreateActorOptions}
 * @param {CreateActorOptions["agent"]} options.agent - a pre-configured agent you'd like to use. Supercedes agentOptions
 * @param {CreateActorOptions["agentOptions"]} options.agentOptions - options to set up a new agent
 * @see {@link HttpAgentOptions}
 * @param {CreateActorOptions["actorOptions"]} options.actorOptions - options for the Actor
 * @see {@link ActorConfig}
 */
export declare const createActor: (
  canisterId: string | Principal,
  options?: CreateActorOptions
) => ActorSubclass<_SERVICE>;

/**
 * Intialized Actor using default settings, ready to talk to a canister using its candid interface
 * @constructs {@link ActorSubClass}
 */
export declare const ic_siwe_provider: ActorSubclass<_SERVICE>;

================
File: src/ic_siwe_provider/declarations/index.js
================
import { Actor, HttpAgent } from "@dfinity/agent";

// Imports and re-exports candid interface
import { idlFactory } from "./ic_siwe_provider.did.js";
export { idlFactory } from "./ic_siwe_provider.did.js";

/* CANISTER_ID is replaced by webpack based on node environment
 * Note: canister environment variable will be standardized as
 * process.env.CANISTER_ID_<CANISTER_NAME_UPPERCASE>
 * beginning in dfx 0.15.0
 */
export const canisterId =
  process.env.CANISTER_ID_IC_SIWE_PROVIDER;

export const createActor = (canisterId, options = {}) => {
  const agent = options.agent || new HttpAgent({ ...options.agentOptions });

  if (options.agent && options.agentOptions) {
    console.warn(
      "Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent."
    );
  }

  // Fetch root key for certificate validation during development
  if (process.env.DFX_NETWORK !== "ic") {
    agent.fetchRootKey().catch((err) => {
      console.warn(
        "Unable to fetch root key. Check to ensure that your local replica is running"
      );
      console.error(err);
    });
  }

  // Creates an actor with using the candid interface and the HttpAgent
  return Actor.createActor(idlFactory, {
    agent,
    canisterId,
    ...options.actorOptions,
  });
};

export const ic_siwe_provider = canisterId ? createActor(canisterId) : undefined;

================
File: .gitignore
================
# IDEs and editors
.vscode/
.idea/

# Ignore temporary files (e.g., emacs or vi)
**/*~

# MacOS system files
.DS_Store
**/.DS_Store

# DFX temporary files
.dfx/
canister_ids.json

# Generated files for declarations
src/declarations/
src/backend/src/declarations/

# Rust build folder
target/

# Node modules and build directories
node_modules/
dist/

# Environment variables
.env
.env.*
.env.local

# General log files
logs/
*.log

# Specific debug logs for various package managers
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Various editor config files and directories
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
*.local # Local configuration files

# Makefiles
Makefile.prod

info/

================
File: Cargo.toml
================
[workspace]
members = [
    "src/backend",
]
resolver = "2"

================
File: CHANGELOG.md
================
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.0.5] - 2024-03-19

### Changed

- Upgraded `ic-use-siwe-identity` to v0.0.11. 
  - fix: A state handling bug prevented the promise returned by login() from working on first call to function. 

## [0.0.4] - 2024-03-19

### Added 

- Custom connect and account dialog components using wagmi directly instead of using RainbowKit.

### Changed

- Upgraded wagmi to v2.5.7. This introduces TanStack Query as an additional dependency.
- Upgraded viem to v2.8.4

### Removed

- Removed RainbowKit as a dependency.


## [0.0.3] - 2024-01-31

### Changed
- Use new convenience state variables from [ic-use-siwe-identity](https://www.npmjs.com/package/ic-use-siwe-identity).
```
  isPreparingLogin: state.prepareLoginStatus === "preparing",
  isPrepareLoginError: state.prepareLoginStatus === "error",
  isPrepareLoginSuccess: state.prepareLoginStatus === "success",
  isPrepareLoginIdle: state.prepareLoginStatus === "idle",
  isLoggingIn: state.loginStatus === "logging-in",
  isLoginError: state.loginStatus === "error",
  isLoginSuccess: state.loginStatus === "success",
  isLoginIdle: state.loginStatus === "idle",  
```
- Use v0.0.4 of the [ic_siwe_provider](https://github.com/kristoferlund/ic-siwe/tree/main/packages/ic_siwe_provider) canister.


## [0.0.2] - 2024-01-16

### Added

- Preloading of SIWE messages! When a users wallet is connected, a SIWE message is requested from the provider canister. This
  means, when user clicks on the "Login" button, the SIWE message is already there and the user can sign it immediately. No
  more waiting for the message to be fetched from the provider canister.

### Changed

- Upgraded to `ic-use-siwe-identity` version `0.0.4` and refactored some code to reflect the changes in the new version.

## [0.0.1] - 2024-01-08

### Added

- First released.

================
File: dfx.json
================
{
  "canisters": {
    "ic_siwe_provider": {
      "candid": "https://github.com/kristoferlund/ic-siwe/releases/download/v0.1.1/ic_siwe_provider.did",
      "declarations": {
        "output": "src/ic_siwe_provider/declarations"
      },
      "type": "custom",
      "wasm": "https://github.com/kristoferlund/ic-siwe/releases/download/v0.1.1/ic_siwe_provider.wasm.gz"
    },
    "backend": {
      "candid": "src/backend/backend.did",
      "declarations": {
        "output": "src/backend/declarations"
      },
      "package": "backend",
      "type": "rust"
    },
    "frontend": {
      "build": [
        "pnpm run build"
      ],
      "source": [
        "dist"
      ],
      "type": "assets"
    }
  },
  "output_env_file": ".env",
  "version": 1
}

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Kristofer Lund

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: Makefile
================
create-canisters:
	dfx canister create --all

deploy-provider:
	dfx deploy ic_siwe_provider --argument "( \
	    record { \
	        domain = \"127.0.0.1\"; \
	        uri = \"http://127.0.0.1:5173\"; \
	        salt = \"salt\"; \
	        chain_id = opt 1; \
	        scheme = opt \"http\"; \
	        statement = opt \"Login to the SIWE/IC demo app\"; \
	        sign_in_expires_in = opt 300000000000; /* 5 minutes */ \
	        session_expires_in = opt 604800000000000; /* 1 week */ \
	        targets = opt vec { \
	            \"$$(dfx canister id ic_siwe_provider)\"; \
	            \"$$(dfx canister id backend)\"; \
	        }; \
	    } \
	)"
	dfx generate ic_siwe_provider

upgrade-provider:
	dfx canister install ic_siwe_provider --mode upgrade --upgrade-unchanged --argument "( \
	    record { \
	        domain = \"127.0.0.1\"; \
	        uri = \"http://127.0.0.1:5173\"; \
	        salt = \"salt\"; \
	        chain_id = opt 1; \
	        scheme = opt \"http\"; \
	        statement = opt \"Login to the SIWE/IC demo app\"; \
	        sign_in_expires_in = opt 300000000000; /* 5 minutes */ \
	        session_expires_in = opt 604800000000000; /* 1 week */ \
	        targets = opt vec { \
	            \"$$(dfx canister id ic_siwe_provider)\"; \
	            \"$$(dfx canister id backend)\"; \
	        }; \
	    } \
	)"
	dfx generate ic_siwe_provider

deploy-backend:
	dfx deploy backend
	dfx generate backend

deploy-frontend:
	pnpm install
	dfx deploy frontend

deploy-all: create-canisters deploy-provider deploy-backend deploy-frontend

run-frontend:
	pnpm install
	pnpm run dev

clean:
	rm -rf .dfx
	rm -rf dist
	rm -rf node_modules
	rm -rf src/declarations
	rm -f .env
	cargo clean

================
File: package.json
================
{
  "name": "shawty-form-video",
  "version": "1.0.0",
  "description": "React demo application and template that demonstrates how to login Ethereum users into an IC canister using the Sign in with Ethereum (SIWE) standard.",
  "author": "Luke Foster <lafoste4@asu.edu>",
  "repository": {
    "type": "git",
    "url": "https://github.com/kristoferlund/ic-siwe-react-demo-rust"
  },
  "bugs": "https://github.com/kristoferlund/ic-siwe-react-demo-rust/issues",
  "homepage": "https://github.com/kristoferlund/ic-siwe-react-demo-rust",
  "keywords": [
    "dfinity",
    "ic",
    "internet computer",
    "react",
    "template",
    "siwe",
    "sign in with ethereum",
    "tailwindcss",
    "typescript",
    "vite"
  ],
  "type": "module",
  "pnpm": {
    "overrides": {
      "viem": "^2.23.0"
    }
  },
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint ./src/frontend/src",
    "preview": "vite preview"
  },
  "dependencies": {
    "@coinbase/onchainkit": "^0.37.5",
    "@dfinity/agent": "^2.2.0",
    "@dfinity/candid": "^2.2.0",
    "@dfinity/identity": "^2.2.0",
    "@dfinity/principal": "^2.2.0",
    "@fortawesome/fontawesome-svg-core": "^6.4.2",
    "@fortawesome/free-brands-svg-icons": "^6.4.2",
    "@fortawesome/free-regular-svg-icons": "^6.4.2",
    "@fortawesome/free-solid-svg-icons": "^6.4.2",
    "@fortawesome/react-fontawesome": "^0.2.0",
    "@headlessui/react": "^1.7.17",
    "@livepeer/react": "^4.2.10",
    "@tanstack/react-query": "^5.28.4",
    "@types/uuid": "^10.0.0",
    "date-fns": "^4.1.0",
    "ic-siwe-js": "^0.2.1",
    "ic-use-actor": "^0.1.0",
    "livepeer": "^3.5.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hot-toast": "^2.4.1",
    "react-router-dom": "^7.2.0",
    "tailwind-merge": "^2.0.0",
    "uuid": "^11.1.0",
    "viem": "^2.23.0",
    "wagmi": "2.12.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.16",
    "dotenv": "^16.3.1",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1"
  }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: README.md
================
# ShawtyFormVideo

A short-form video platform built on the Internet Computer with Base chain tipping and onramp integration.

## Overview

ShawtyFormVideo is a modern video platform that allows users to:
1. Upload and watch short-form videos via LivePeer integration
2. Tip content creators with cryptocurrency on Base chain
3. Acquire cryptocurrency directly in-app via Coinbase Developer Platform onramp
4. Sign in with Ethereum (SIWE) for a seamless web3 experience
5. Follow creators, comment on videos, and build a social network

The platform is built using:
1. Rust for the backend canister on Internet Computer
2. React + Vite + TypeScript for the frontend
3. LivePeer for video storage and streaming
4. Coinbase Developer Platform for cryptocurrency onramp
5. Base chain for tipping transactions

1. Clone the Repository & Rename
	1.	Clone the code:

git clone https://github.com/kristoferlund/ic-siwe-react-demo-rust.git ShawtyFormVideo
cd ShawtyFormVideo


	2.	Optional: Rename references (folder names, package.json, dfx.json, etc.) if you want to use ShawtyFormVideo as the name. For example, in dfx.json, you might change:

// Original
"canisters": {
  "backend": { ... },
  "ic_siwe_provider": { ... },
  "frontend": { ... }
}

to

// If you want a different canister name
"canisters": {
  "shawty_form_video_backend": { ... },
  "ic_siwe_provider": { ... },
  "shawty_form_video_frontend": { ... }
}

In package.json, you could change:

{
  "name": "ic-siwe-react-demo-rust",
  // ...
}

to

{
  "name": "shawty-form-video",
  // ...
}

The code will still work with the original names, so renaming is optional.

2. Install Dependencies

This repository uses pnpm as its package manager (though yarn or npm could also be used if you prefer). Make sure you have pnpm installed:

npm install -g pnpm

From the project root, run:

pnpm install

This will install both frontend and general dev dependencies for the entire project.

3. Local Development
	1.	Start dfx (the Internet Computer local replica):

dfx start --clean --background


	2.	Deploy the canisters (both the backend and the ic_siwe_provider canister) to your local replica:

make deploy-all

	•	This runs dfx deploy ic_siwe_provider with a set of init arguments (domain, uri, salt, chain_id, etc.).
	•	Then it deploys your backend canister, hooking it up to the SIWE provider canister.
	•	Finally it deploys your React web assets as an “assets canister” (the frontend).

	3.	Run the frontend dev server:

make run-frontend

or equivalently

pnpm run dev

By default, this will start Vite on http://127.0.0.1:5173.
You can open your browser at http://127.0.0.1:5173 to see the application.

Project Layout Recap
	•	src/backend/
Rust code for the main canister (where you’ll write your domain logic).
	•	ic_siwe_provider/
Pre-built canister + declarations for Sign in with Ethereum.
You typically won’t need to modify the code inside ic_siwe_provider; it’s added as a dependency.
	•	src/frontend/
Your React + TypeScript frontend, using wagmi and viem for Ethereum integration and ic-use-siwe-identity for IC identity integration.
	•	dfx.json
IC configuration (which canisters exist, how to build them, etc.).
	•	Makefile
Helper tasks to create, deploy, upgrade canisters, and run the frontend.

4. How the SIWE Flow Works
	1.	The frontend requests a SIWE message from the ic_siwe_provider canister.
	2.	The user signs the message with their Ethereum wallet.
	3.	The frontend sends the signed message back to the ic_siwe_provider.
	4.	The ic_siwe_provider canister verifies the signature and generates a delegated IC identity for the user.
	5.	The frontend can now make authenticated calls to your backend canister, as the user’s principal is recognized.

Hooking into your own backend
	•	The main code for storing or retrieving data from your backend canister is in src/backend/.
	•	The boilerplate shows a simple user-profile system.
	•	Modify or extend the backend Rust code to add your own domain logic, endpoints, etc.

5. Extending the Backend Canister

Inside src/backend/src/service/, you have example modules:
	•	get_my_profile.rs
	•	list_profiles.rs
	•	save_my_profile.rs

These demonstrate how to:
	•	Query a profile (with #[query] functions)
	•	Update or save a profile (with #[update] functions)

Steps to add a new endpoint
	1.	Create a new file in src/backend/src/service/ with a function annotated as either #[query] or #[update].
	2.	Add it to mod.rs (so it’s included in the final build).
	3.	Update your DID file in src/backend/backend.did to define new methods or new data types.
	4.	Rebuild and redeploy:

make deploy-backend

or

dfx deploy backend



That’s it. On the frontend, you’d import the new method from the auto-generated actor in src/backend/declarations/ (or via ic-use-actor if you prefer).

6. Deploying to the ICP Mainnet

When you are ready to deploy to mainnet, you have a couple of steps:
	1.	Authenticate with your dfx identity (ensure it has sufficient cycles or an available wallet).
Typically:

dfx identity use <your_mainnet_identity_name>


	2.	Set your environment to the IC mainnet:

dfx network use ic


	3.	Configure dfx.json for mainnet (if you want custom settings, e.g., canister names, WASM compression, etc.).
	4.	Deploy:

dfx deploy --network ic ic_siwe_provider --argument '(record { ... })'
dfx deploy --network ic backend --argument '(principal "<ic_siwe_provider_canister_id>")'
dfx deploy --network ic frontend

Or you can run:

make deploy-all

with the environment set to ic. You may need to tweak the Makefile arguments for production (different domain, scheme = “https”, etc.).

	5.	Update your canister IDs in any environment variables or .env file if needed (Vite needs them for the React define block in vite.config.ts).

Important SIWE Settings for Production
	•	In the Makefile, the dfx deploy ic_siwe_provider --argument "(record { ... })" call includes domain, uri, etc.:

domain = "127.0.0.1";
uri = "http://127.0.0.1:5173";
scheme = opt "http";

For mainnet, you’ll want to set the domain to your actual domain (e.g., mydapp.com) and the scheme to "https", and so on:

domain = "mydapp.com";
uri = "https://mydapp.com";
scheme = opt "https";

This ensures SIWE messages reference your real domain and thus are recognized as valid by the user’s wallet.

7. Common Commands

A quick cheat sheet for the most common commands:
	•	dfx start --clean --background
Starts a fresh local replica in the background.
	•	make create-canisters
Creates the canisters in dfx.json.
	•	make deploy-provider
Deploys only the ic_siwe_provider.
	•	make deploy-backend
Deploys only the backend.
	•	make deploy-frontend
Deploys only the frontend assets canister.
	•	make deploy-all
Runs all of the above steps in one go.
	•	make run-frontend
Runs pnpm run dev to start the Vite dev server for local development.
	•	dfx canister call <canister-name> <method>
To call canister methods from the command line.

8. Customizing Your Project
	1.	Use your own UI – You can replace or remove the entire profile/ flow with your own forms, images, etc.
	2.	Use additional canisters – You can add more Rust canisters in dfx.json and set up cross-canister calls from your backend to the new canisters.
	3.	Change Ethereum chain – In the file src/frontend/src/wagmi/wagmi.config.ts, you can add or remove supported EVM chains. If you want multiple testnets or other mainnets, you can add them in chains array.

9. Summary
	•	Clone the repo into your new project folder.
	•	Install dependencies (pnpm install).
	•	Start local development with dfx start --clean --background and make deploy-all.
	•	Run the frontend with pnpm run dev.
	•	Modify the Rust canister code in src/backend/ for your business logic.
	•	Deploy to the ICP mainnet by switching your dfx network to ic and providing production arguments (domain, scheme, etc.) to the SIWE provider canister.

This boilerplate should give you a quick starting point to:
	•	Build cross-chain dapps bridging Ethereum wallets into the IC.
	•	Store, query, and manage user data on your own custom Rust canisters.
	•	Expand the SIWE flow with additional logic and user experiences.

If you have any trouble with the above steps or want to explore more about “Sign in with Ethereum” for the Internet Computer, check out:
	•	ic-siwe GitHub organization
	•	ic-siwe-provider docs
	•	ic-use-siwe-identity docs

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    fontFamily: {
      sans: ["Jost", "Sans-serif"],
    },
    extend: {},
  },
  plugins: [],
};

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

================
File: tsconfig.app.tsbuildinfo
================
{"root":["./src/backend/declarations/backend.did.d.ts","./src/backend/declarations/index.d.ts","./src/frontend/src/app.tsx","./src/frontend/src/authguard.tsx","./src/frontend/src/main.tsx","./src/frontend/src/vite-env.d.ts","./src/frontend/src/cdp/customfundwallet.tsx","./src/frontend/src/cdp/fundwallet.tsx","./src/frontend/src/cdp/onchainkitprovider.tsx","./src/frontend/src/cdp/index.ts","./src/frontend/src/components/accountdialog.tsx","./src/frontend/src/components/addresspill.tsx","./src/frontend/src/components/connectdialog.tsx","./src/frontend/src/components/githubicon.tsx","./src/frontend/src/components/principalpill.tsx","./src/frontend/src/components/header/ethbutton.tsx","./src/frontend/src/components/header/header.tsx","./src/frontend/src/components/header/identitybutton.tsx","./src/frontend/src/components/header/principaldialog.tsx","./src/frontend/src/components/header/sessionbutton.tsx","./src/frontend/src/components/header/sessiondialog.tsx","./src/frontend/src/components/layout/desktoplayout.tsx","./src/frontend/src/components/layout/mobilelayout.tsx","./src/frontend/src/components/login/connectbutton.tsx","./src/frontend/src/components/login/loginbutton.tsx","./src/frontend/src/components/login/loginpage.tsx","./src/frontend/src/components/profile/allprofiles.tsx","./src/frontend/src/components/profile/editprofile.tsx","./src/frontend/src/components/profile/followsection.tsx","./src/frontend/src/components/profile/noprofilemessage.tsx","./src/frontend/src/components/profile/profilecard.tsx","./src/frontend/src/components/search/searchbar.tsx","./src/frontend/src/components/search/searchresults.tsx","./src/frontend/src/components/search/simplesearch.tsx","./src/frontend/src/components/search/index.ts","./src/frontend/src/components/ui/button.tsx","./src/frontend/src/components/ui/dialog.tsx","./src/frontend/src/components/ui/followbutton.tsx","./src/frontend/src/components/ui/pill.tsx","./src/frontend/src/components/video/commentsection.tsx","./src/frontend/src/components/video/tiphistory.tsx","./src/frontend/src/components/video/tipmodal.tsx","./src/frontend/src/components/video/videogrid.tsx","./src/frontend/src/components/video/videopage.tsx","./src/frontend/src/components/video/videoviewpage.tsx","./src/frontend/src/components/video/index.ts","./src/frontend/src/context/searchcontext.tsx","./src/frontend/src/eth/utils/shortenethaddress.ts","./src/frontend/src/ic/actors.tsx","./src/frontend/src/livepeer/livepeerprovider.tsx","./src/frontend/src/livepeer/videofeed.tsx","./src/frontend/src/livepeer/videoplayer.tsx","./src/frontend/src/livepeer/videoupload.tsx","./src/frontend/src/livepeer/index.ts","./src/frontend/src/livepeer/types.ts","./src/frontend/src/utils/api.ts","./src/frontend/src/wagmi/is-chain-id-supported.tsx","./src/frontend/src/wagmi/wagmi.config.ts","./src/ic_siwe_provider/declarations/ic_siwe_provider.did.d.ts","./src/ic_siwe_provider/declarations/index.d.ts"],"errors":true,"version":"5.7.3"}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: tsconfig.node.tsbuildinfo
================
{"root":["./vite.config.ts"],"version":"5.7.3"}

================
File: vite.config.ts
================
import * as dotenv from "dotenv";

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

dotenv.config();

const processEnvCanisterIds = Object.fromEntries(
  Object.entries(process.env)
    .filter(([key]) => key.startsWith("CANISTER_ID"))
    .map(([key, value]) => [`process.env.${key}`, JSON.stringify(value)])
);

export default defineConfig({
  build: {
    outDir: "../../dist",
  },
  plugins: [react()],
  root: "src/frontend",
  server: {
    host: "127.0.0.1",
    proxy: {
      // Proxy all http requests made to /api to the running dfx instance
      "/api": {
        target: `http://127.0.0.1:4943`,
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, "/api"),
      },
    },
  },
  define: {
    // Define the canister ids for the frontend to use. Currently, dfx generated
    // code relies on variables being defined as process.env.CANISTER_ID_*
    ...processEnvCanisterIds,
    "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV),
    "process.env.DFX_NETWORK": JSON.stringify(process.env.DFX_NETWORK),
    global: "globalThis",
  },
});



================================================================
End of Codebase
================================================================
